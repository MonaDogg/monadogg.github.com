<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[MonaDogg]]></title>
  <link href="http://MonaDogg.github.io/atom.xml" rel="self"/>
  <link href="http://MonaDogg.github.io/"/>
  <updated>2014-05-04T13:11:59+08:00</updated>
  <id>http://MonaDogg.github.io/</id>
  <author>
    <name><![CDATA[MonaDogg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[GCD]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/03/10/GCD/"/>
    <updated>2014-03-10T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/03/10/GCD</id>
    <content type="html"><![CDATA[<h1>Grand Central Dispatch(GCD)</h1>

<p>从iOS4开始实现</p>

<p>GCD是异步执行任务的技术之一,一般将应用程序中记述的线程管理用的代码在系统级的实现.开发者只需要定义想执行的任务并追加到适当的Dispatch Quere中,GCD就能生成必要的线程并计划执行任务.由于线程管理是作为系统的一部分来实现的,因此可以统一管理,也可以执行任务,这样就比以前的线程更有效率.</p>

<p>下面的代码是在后台线程中执行长时间处理,处理结束的时候,主线程处理该结果的源代码.</p>

<pre><code>dispatch_async(queue,^{
    &lt;!-- 长时间处理 --&gt;
    &lt;!-- 例如画像识别 --&gt;
    &lt;!-- 例如数据库访问 --&gt;

    dispatch_async(dispatch_get_main_queue(),^{
        &lt;!-- 只有在主线程中执行的任务 --&gt;
        &lt;!-- 例如用户的界面刷新 --&gt;
    });
});
</code></pre>

<p>在GCD之前,cocoa框架提供了NSObject类的performSelectorInBackground:withObject和performSelectorOnMainThread实例方法等多线程技术,但是代码实现起来很累赘,例如:</p>

<pre><code>-(void)launchThreadByNSObject_performSelectorInBackground_withObject{
    &lt;!-- 执行后台处理 --&gt;
    [self performSelectorInBackground:@selector(doWork) withObject:nil];
}

-(void)doWork{
    NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];
    &lt;!-- 长时间的处理,例如图像识别,数据库访问 --&gt;
    &lt;!-- 长时间处理结束之后,主线程调用其处理结果 --&gt;
    [self performSelectorOnMainThread:@selector(doneWork) withObject:nil waitUntilDone:NO];
    [pool drain];
}

-(void)doneWork{
    &lt;!-- 仅有主线程可以执行的处理,例如用户界面的刷新 --&gt;
}
</code></pre>

<p>gcd是真正提供了多个cpu核并行执行多个线程的操作.
&ldquo;主线程&#8221;用来描绘用户界面,处理触摸屏幕的事件等.</p>

<h2>GCD的API</h2>

<p>开发者要做的只是定义想执行的任务并追加到适当的Dispatch Queue中.</p>

<p>1)Serial Dispatch Queue连续的执行,等待现在执行中处理结束.每次处理一个任务.</p>

<p>2)Concurrent Dispatch Queue并发的执行,不等待现在执行中的处理结束,具体创建几个线程,由系统决定,执行顺序会根据处理内容和系统状态发生变化,它不同于执行
顺序固定的Serial Dispatch Queue,在不想干煸执行处理顺序,或者不想并行执行多个处理时使用Serial Dispatch Queue.</p>

<h2>dispatch_queue_create</h2>

<p>下面是创建一个Serial Dispatch Queue的方法:</p>

<pre><code>dispatch_queue_t mySerialDispatchQueue = 
    dispath_queue_create("com.example.gcd.MySerialDispatchQueue",NULL);
</code></pre>

<p>虽然Serial Dispatch Queue每次只能执行一个任务,但是通过dispatch_queue_create创建多个Serial Dispatch Queue,依然可以并发执行.每个Serial Dispatch Queue都会创建一个线程,会消耗大量的内存,引起大量的上下文切换,降低系统的响应性能.</p>

<p>避免多个线程更新相同资源导致数据竞争时,使用Serial Dispatch Queue.</p>

<p>创建Serial Dispatch Queue的时候,第一个参数是Dispatch Queue的名字,第二个参数设置为NULL,例如下面所示:</p>

<pre><code>dispatch_queue_t mySerialDispatchQueue = 
    dispath_queue_create("com.example.gcd.MySerialDispatchQueue",NULL);
</code></pre>

<p>创建Concurrent Dispatch Queue的时候,第一个参数是Dispatch Queue的名字,第二个参数设置为DISPATCH_QUEUE_CONCURRENT,例如下面所示:</p>

<pre><code>dispatch_queue_t myConcurrentDispatchQueue = 
    dispath_queue_create("com.example.gcd.MySerialDispatchQueue",DISPATCH_QUEUE_CONCURRENT);
</code></pre>

<p>通过dispath_queue_create创建的Dispatch Queue必须在结束的时候,手动释放,相对应的也包含相应的retain方法:</p>

<pre><code>dispatch_release(mySerialDispatchQueue);
dispatch_retain(mySerialDispatchQueue);
</code></pre>

<p>例如:</p>

<pre><code>dispatch_queue_t myConcurrentDispatchQueue = 
    dispath_queue_create("com.example.gcd.MySerialDispatchQueue",DISPATCH_QUEUE_CONCURRENT);
dispath_async(queue,^{NSLog(@"block on myConcurrentDispatchQueue");});
dispatch_release(myConcurrentDispatchQueue);
</code></pre>

<p>在创建dispatch_queue后,立即调用dispatch_release并不会产生问题,是因为在block追加到Dispath Queue后,
自动的调用了dispatch_retain方法,在block执行完成后,自动释放.</p>

<p>凡是带有GCD的API中含有&#8221;create&#8221;的API生成对象的时候,在不需要的时候,需要立即调用dispatch_release方法进行释放.
通过函数或者方法获取Dispath_queue以及其他命名含有create的api生成的对象时,有必要通过dispatch_retain方法持有,并在不需要的时候dispatch_release.</p>

<p>???如何返回???</p>

<h3>Main Dispatch Queue/Global Dispatch Queue</h3>

<p>这两个是不需要创建的Dispath Queue.
Main Dispatch Queue是在主线程中执行的Dispath Queue,因为主线程只有一个,所以是Serial Dispatch Queue,其和NSObject的performSelectorOnMainThread方法作用相同,</p>

<p>Global Dispatch Queue是所有应用程序都能使用的Concurrent Dispatch Queue,没有必要自己生成Concurrent Dispatch Queue,只需要获取Global Dispatch Queue即可.</p>

<p>另外其还具有四个优先级,分别为高优先级,默认优先级,低优先级和后台优先级.
各种Dispath Queue获取方法如下:</p>

<pre><code>&lt;!-- 获取MAIN DISPATCH QUEUE --&gt;
dispatch_queue_t mainDispatchQueue = dispatch_get_main_queue();

&lt;!-- 获取高优先级GLOBAL DISPATCH QUEUE --&gt;
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,0);

&lt;!-- 获取默认优先级GLOBAL DISPATCH QUEUE --&gt;
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);

&lt;!-- 获取低优先级GLOBAL DISPATCH QUEUE --&gt;
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,0);

&lt;!-- 获取后台优先级GLOBAL DISPATCH QUEUE --&gt;
dispatch_queue_t globalDispatchQueueHigh = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);
</code></pre>

<p>对MAIN DISPATCH QUEUE和GLOBAL DISPATH QUEUE执行dispatch_release和dispatch_retain方法没有任何效果.</p>

<p>下面的例子为在MAIN DISPATCH QUEUE和GLOBAL DISPATCH QUEUE同时作用的代码实例:</p>

<pre><code>dispath_async(dispath_get_global_queue(DISPATH_QUEUE_PRIORITY_DEFAULT,0),^{
    &lt;!-- 可以并行处理的任务 --&gt;
  dispath_async(dispatch_get_main_queue(),^{
    &lt;!-- 主线程中的任务 --&gt;
  });
});
</code></pre>

<h3>dispatch_set_target_queue</h3>

<p>dispatch_queue_create函数生成的Dispatch Queue不管是Serial还是Concurrent的dispatch queue,都是与默认有限的Global Dispatch Queue相同执行优先级的线程.而变更Dispatch Queue要使用dispatch_set_target_queue函数,例如:</p>

<pre><code>dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create("com.alex.mySerialDispatchQueue",NULL);
dispatch_queue_t globalDispatchQueueBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,0);
dispatch_set_target_queue(mySerialDispatchQueue,globalDispatchQueueBackground);
</code></pre>

<p>将需要变更优先级的queue作为函数的第一个参数,指定需要相同优先级的queue作为第二个参数.</p>

<h3>dispatch_after</h3>

<p>想要在指定的时间之后执行,需要使用dispatch_after
dispatch_after并不是在指定的时间后执行处理,而只是在指定的时间后追加到Dispatch Queue中.</p>

<pre><code>dispatch_tme_t time = dispatch_time(DISPATCH_TIME_NOW,3ull * NSEC_PER_SEC);
dispatch_after(time,dispatch_get_main_queue(),^{
    NSLog(@"wait for 3 seconds");
});
</code></pre>

<p>dispatch_time函数从第一个参数开始,到第二个参数指定的毫微秒单位时候后的时间.</p>

<p>NSEC_PER_SEC:秒为单位的数值
NESC_PRE_MSEC:毫秒为单位的数值</p>

<p>可以很轻松的将NSDate时间转换为dispatch_time_t类型:</p>

<pre><code>dispatch_time_t getDispatchTimeByDate(NSDate *date){
    NSTimeInterval interval;
    double second,subsecond;
    struct timespec time;
    dispatch_time_t milestone;

    interval = [date timeIntervalSince1970];
    subsecond = modf(interval,&amp;second);
    time.tv_sec = second;
    time.tv_nsec = subsecond * NSEC_PER_SEC;
    milestone = dispatch_walltime(&amp;time,0);

    return milestone;
}
</code></pre>

<h3>Dispatch Group</h3>

<p>当追加到多个Dispatch Queue中多个处理全部结束的时候想要执行结束处理,当你使用Serial Dispatch Queue的时候,只需要将任务追加到最后,但是当你使用
Concurrent Dispatch Queue中的时候,源代码变的很复杂.这时候用Dispatch Group就十分合适.</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_group_t group = dispatch_group_create();
&lt;!-- 含有create创建的函数,需要在使用后使用release --&gt;

dispatch_group_async(group,queue,^{NSLog(@"blk0";)});
dispatch_group_async(group,queue,^{NSLog(@"blk1";)});
dispatch_group_async(group,queue,^{NSLog(@"blk2";)});

dispatch_group_notify(group,dispatch_get_main_queue(),^{NSLog(@"work is done!")});
dispatch_relelase(group);
</code></pre>

<p>代码中的其他任务执行顺序不变,但是notify任务一定是最后执行的.</p>

<p>dispatch_group_notify可以监测到所人吴的执行结束,一旦结束了,就把最后的处理添加到指定的Dispatch Queue中.
dispatch_group_async函数和dispatch_async作用相同.</p>

<p>diaptch_queue_wait函数近等待全部处理执行结束.</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_group_t group = dispatch_group_create();
&lt;!-- 含有create创建的函数,需要在使用后使用release --&gt;

dispatch_group_async(group,queue,^{NSLog(@"blk0";)});
dispatch_group_async(group,queue,^{NSLog(@"blk1";)});
dispatch_group_async(group,queue,^{NSLog(@"blk2";)});

dispatch_group_wait(group,DISPATCH_TIME_FOREVER);
dispatch_relelase(group);
</code></pre>

<p>dispatch_group_wait第二个参数是等待的时间,DISPATCH_TIME_FOREVER是永远等待的意思,只要group的处理没有结束,我们就会一直等待.这个方法返回的情况一般有两种,一种是组内的所有任务都结束了,另外一种是等待的时间到了,一般会在其后面进行group的release操作.</p>

<h3>dispatch_barrier_async</h3>

<p>写入处理确实不可以和其他的写入处理以及包含读取处理的其他某些处理并行执行,但是如果读取处理仅仅和读取处理并行执行,那么多个并行处理就不会发生问题.
也就是说为了搞笑的进行访问,读取处理追加到Concurrent Dispatch Queue中,写入处理在没有读取处理没有执行的状态下,追加到Serial Dispach Queue.(在写入处理之前,读取处理不可执行).
值得注意的是需要同dispatch_queue_create生成的Concurrent Dispatch Queue一起工作.
这时候使用dispatch_barrier_async就十分合适:</p>

<p>所有blk0_for_reading都是并行处理的,直到执行到blk_for_writing此时变成串行处理.</p>

<pre><code>dispatch_queue_t queue = dispatch_queue_create("com.monadogg.queue",DISPATCH_QUEUE_CONCURRENT);

dispatch_async(queue,blk0_for_reading);
dispatch_async(queue,blk1_for_reading);
dispatch_async(queue,blk2_for_reading);
dispatch_barrier_async(queue,blk_for_writing);
dispatch_async(queue,blk3_for_reading);
dispatch_async(queue,blk4_for_reading);
dispatch_async(queue,blk5_for_reading);

dispatch_release(queue);
</code></pre>

<h3>dispatch_sync / dispatch_async</h3>

<p>dispatch_async表示&#8221;非同步&#8221;的追加到指定的Dispatch Queue中,立刻返回,不做任何等待.
dispatch_sync意味着同步的,也就是在追加的Block执行结束之前,dispatch_sync一直会在这里等待,一直等待block执行结束.</p>

<h3>dispatch_apply</h3>

<p>该函数按照指定的次数将指定的block追加到指定的Dsipatch Queue中,并等待全部处理执行结束.
第一个参数是执行的次数,第二个参数是追加的queue,第三个参数是带有参数的block.</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_apply(10,queue,^(size_t index){
    NSLog(@"%zu",index);
});
NSLog(@"done");
</code></pre>

<p>如果希望NSLog(@&ldquo;done&rdquo;)异步执行,就将这段代码放在dispatch_async中即可,形如:</p>

<pre><code>dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);
dispatch_async(queue,{
    dispatch_apply(10,queue,^(size_t index){
        NSLog(@"%zu",index);
    });
    NSLog(@"done");
});
</code></pre>

<h3>dispatch_suspend/dispatch_resume</h3>

<p>挂起指定的dispatch queue:</p>

<pre><code>dispatch_suspend(queue);
</code></pre>

<p>恢复指定的dispatch queue:</p>

<pre><code>dispatch_resume(queue);
</code></pre>

<h3>Dispatch Semaphore</h3>

<p>自从ios4.0/mac osx10.6引入了GCD之后，让我们在使用多线程的时候确实方便了很多，关于GCD的一些介绍和使用本站中已经转过一位资深开发者的几篇系列文章，非常彻底的介绍了GCD的用法和一些特性，有兴趣的朋友可以去翻阅。
但当我们在处理一系列线程的时候，当数量达到一定量，在以前我们可能会选择使用
NSOperationQueue来处理并发控制，但如何在GCD中快速的控制并发呢？答案就是
dispatch_semaphore，对经常做unix开发的人来讲，我所介绍的内容可能就显得非常入门级了，信号量在他们的多线程开发中再平常不过了。
在GCD中有三个函数是semaphore的操作，分别是：</p>

<pre><code>dispatch_semaphore_create          创建一个semaphore
dispatch_semaphore_signal          发送一个信号
dispatch_semaphore_wait              等待信号
</code></pre>

<p>简单的介绍一下这三个函数，第一个函数有一个整形的参数，我们可以理解为信号的总量，dispatch_semaphore_signal是发送一个信号，自然会让信号总量加1，dispatch_semaphore_wait等待信号，当信号总量少于0的时候就会一直等待，否则就可以正常的执行，并让信号总量-1，根据这样的原理，我们便可以快速的创建一个并发控制。</p>

<pre><code>dispatch_group_t group = dispatch_group_create();
dispatch_semaphore_t semaphore = dispatch_semaphore_create(10);
dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
for (int i = 0; i &lt; 100; i++)
{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    dispatch_group_async(group, queue, ^{
        NSLog(@"%i",i);
        sleep(2);
        dispatch_semaphore_signal(semaphore);
    });
}
dispatch_group_wait(group, DISPATCH_TIME_FOREVER);
dispatch_release(group);
dispatch_release(semaphore);
</code></pre>

<p>简单的介绍一下这一段代码，创建了一个初使值为10的semaphore，每一次for循环都会创建一个新的线程，线程结束的时候会发送一个信号，线程创建之前会信号等待，所以当同时创建了10个线程之后，for循环就会阻塞，等待有线程结束之后会增加一个信号才继续执行，如此就形成了对并发的控制，如上就是一个并发数为10的一个线程队列。</p>

<h3>dispatch_once</h3>

<p>dispatch_once函数是保证在应用程序执行中只执行一次指定处理的api,通过该函数即便是在多线程环境下执行,也可以保证百分之百安全.</p>

<pre><code>static dispatch_one_t pred;
dispatch_once(&amp;pred,^{
    &lt;!-- 初始化 --&gt;
});
</code></pre>

<p>其等价于:</p>

<pre><code>static int initalized = NO;
if(initalized == NO)
{
    &lt;!-- 初始化 --&gt;
    initalized = YES;
}
</code></pre>

<h3>Dispatch I/O</h3>

<p>在读取大文件的时候,如果将文件分成合适的大小,并使用Global Dispatch Queue并列读取的话,应该比一般的读取速度快不少.
通过DispatchI/O和Dispatch Data就可以这么做.</p>

<p>注意网络请求中:线程是魔鬼,应该首先选用Cocoa提供的异步网络请求API.</p>

<p>参考并感谢:
老谭的博客:<a href="http://www.tanhao.me/">http://www.tanhao.me/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MRC与ARC]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/03/01/MRC_AND_ARC/"/>
    <updated>2014-03-01T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/03/01/MRC_AND_ARC</id>
    <content type="html"><![CDATA[<h2>MRC</h2>

<p>dealloc实际上是调用了释放了你对象的内存空间,你永远不应该显示的调用dealloc方法(虽然这样是可行的),这个dealloc方法将有运行时进行调用.如果你使用了arc,并且需要继承dealloc方法,需要在该方法的末尾调用父类的dealloc方法.</p>

<p>copy</p>

<p>retain</p>

<p>等方法对内存的影响</p>

<p>为什么字符串用copy?</p>

<h3>1.1什么是自动引用计数</h3>

<p>在LLVM编译器中设置ARC为有效的状态,就无需再次键入retain或者是release代码了.</p>

<pre><code>1)使用xcode4.2以上的版本
2)使用LLVM编译器3.0或以上的版本
3)编译器中arc的设置为有效
</code></pre>

<h3>1.2内存管理和引用计数</h3>

<p>办公室开灯和引用计数的故事</p>

<p>开灯       &mdash;> 生成对象
需要照明     &mdash;> 持有对象
不需要照明 &mdash;>  释放对象
关灯   &mdash;>  废弃对象</p>

<h4>内存管理的思考方式</h4>

<p>对象的操作和oc对应的方法:</p>

<pre><code>生成并持有对象:alloc/new/copy/mutableCopy等等
持有对象:retain
释放对象:release
废弃对象:dealloc
</code></pre>

<p>1)自己生成的对象,自己持有</p>

<p>使用alloc,new,copy,mutableCopy方法生成的对象只有自己持有.按照某些约定命名的方法,也能声称自己持有的对象.</p>

<p>copy方法利用基于NSCopying方法的约定,由各类实现copyWithZone:方法生成并持有对象的副本,生成不可变更的对象.
mutableCopy方法利用基于NSMutableCopying方法的约定,由各类实现mutableCopyWithZone:方法生成并持有对象的副本,生成可变更的对象.
另外使用下面名称命名的时候,也意味着自己生成并持有对象:
allocMyObject;newThatObject;copyThis;mutableCopyYourObject;</p>

<p>对于下面的方法,即便使用了alloc/new/copy/mutableCopy名称开头,也并不属于同一类方法,注意这里的驼峰明明:
allocate;newwe;copying;mutableCopyed;</p>

<p>2)非自己生成的对象,自己也能持有</p>

<p>利用alloc/new/copy/mutableCopy方法以外的方法持有对象,例如使用NSMutableArray的array类方法赋值给变量obj的时候,obj并不持有该对象,调用retain方法就可以持有该对象.</p>

<p>3)不再需要自己持有的对象时释放</p>

<p>当一个对象不再需要的时候,就将其释放了,例如使用alloc/new/copy/mutableCopy/retain等方法持有的对象,一旦不再需要就需要调用release方法,将其释放.</p>

<p>4)非自己持有的对象无法释放</p>

<p>释放非自己持有的对象的时候,就会产生问题,例如为autorelease的对象调用release方法.</p>

<h4>autorelease</h4>

<p>c语言的作用域,若某些自动变量超过了其作用域,该自动变亮将要自动废弃.autorelease会像c语言的自动变亮那样对待对象实例.
aotorelease的具体使用方法是:
1)生成并持有NSAutoreleasePool对象
2)调用已分配对象的aotorelease方法
3)废弃NSAutoreleasePool对象</p>

<pre><code>NSAutoreleasePool *pool = [[NSAutoreleasePool alloc]init];
id obj = [[NSObject alloc]init];
[obj autorelease];
[pool drain];
</code></pre>

<p>NSRunLoop每次循环过程中NSAutoreleasePool对象被生成或者废弃.</p>

<p>1)放入autoreleasepool并不会增加引用计数,如果一个对象添加到autorelease后,就不能再调用这个对象release的方法了.也就是说autorelease方法相当于一个延后操作的release方法,其并不会增加引用计数.
2)使用autorelease方法,可以使的对象存在,但是并不持有该对象
3)autorelease提供在对象超出指定的生存范围的时候能够自动并正确的释放
4)添加到集合以后会增加引用计数,例如array,当集合元素销毁以后,该元素的引用计数会自己销毁.
5)当你放入到autorelease pool中后,该对象就不会被你持有了.</p>

<h2>ARC</h2>

<p>在LLVM中编译器中设置ARC为有效状态,就无需再次键入retain或者是release代码.</p>

<h3>1.1ARC规则</h3>

<p>*acr下并不关心引用计数</p>

<p>设置ARC有效的编译方法如下所示:</p>

<pre><code>1)使用clang(LLVM编译器)3.0或者以上版本
2)指定编译器的属性为"-fobjc-arc"
</code></pre>

<p>没有必要在arc模式下调用dealloc方法,并且也不能调用[super dealloc]方法,但是如果你在对象销毁的时候,需要做一些额外的操作,例如注销通知中心的对象,你可以在这里编写额外的代码.</p>

<p>循环引用容易发生内存泄漏,发生内存泄漏的原因是因为引用计数一直大于1.</p>

<h4>所有权修饰符</h4>

<p>1)<strong>strong
</strong>strong是id类型和对象类型的默认所有权修饰符,所以下面两行代码是等价的:</p>

<pre><code>id obj = [[NSObject alloc]init];

id __strong obj = [[NSObject alloc]init];
</code></pre>

<p>__strong修饰符表示对对象的&#8221;强引用&#8221;,持有强引用的变量在超出作用域的时候被废弃,随着强饮用的失效,引用的对象会随之释放.所以下面的代码可以正常的执行:(自动帮你持有对象了,对象在没有强引用指向的时候废弃)</p>

<pre><code>{
id __strong obj = [NSMutableArray array];
//因为__strong的作用,持有对象
}
超出作用域对象被自动释放

{
id __strong obj = [NSObject alloc]init];
//因为__strong的作用,持有对象
}
超出作用域对象被自动释放
</code></pre>

<p>注意成员变量和形参是__strong类型,在超出作用域后能够正常的释放.</p>

<p><strong>strong,</strong>weak,__autoreleasing可以保证这些变量的初始化都是nil.</p>

<p>arc下容易产生引用循环,有如下类定义:</p>

<pre><code>#import &lt;Foundation/Foundation.h&gt;

@interface TestObject : NSObject

@property(nonatomic,strong) TestObject *myObj;

@end
</code></pre>

<p>情况1:</p>

<pre><code>TestObject *test1 = [TestObject new];    //对象T1
TestObject *test2 = [TestObject new];    //对象T2
test1.myObj = test2;
</code></pre>

<p>情况2:</p>

<pre><code>TestObject *test1 = [TestObject new];
TestObject *test2 = [TestObject new];
test1.myObj = test2;
test2.myObj = test1;   
</code></pre>

<p>情况1:
当函数超出作用域的时候,指向对象T1的强引用test1失效,导致T1对象的释放,
随即test1.myObj也失效,导致指向对象T2的强引用-1,
然后强饮用test2指针超出作用域后失效,导致对象T2释放,
最终所有的对象均被释放</p>

<p>情况2:
当函数超出作用域的时候,指向对象T1的强引用test1失效,导致T1对象的强引用-1,目前为1,
指向对象T2的强引用test2失效,导致T2对象强引用-1,目前为1,
最终对象T1和T2,都因为引用计数大于1而不能释放内存.</p>

<p>2)__weak</p>

<p><strong>weak和</strong>stong指针正好相反,提供弱引用,弱引用并不能持有对象的实例.并且有如果弱引用指向的对象被废弃后,该弱引用将被自动设置为nil.
通过判断<strong>weak修饰的变量是否为nil,则可以判断对象是否被释放,需要注意的是仅仅支持iOS5以上的应用程序,在iOS4以下的应用程序,可以使用</strong>unsafe__unretained修饰符来修饰.</p>

<p>3)__unsafa_unretained</p>

<p>是不安全的内存修饰符,其并不属于编译器内存管理的对象。与weak相同的地方是并不会持有对象，如果对象被释放了以后，并不会被设置为nil，从而可能访问了错误的内存。</p>

<p>4)<strong>autoreleasing
使用了@autoreleasepool块来代替，当有</strong>autoreleasing修饰符修饰变量的时候,就相当于MRC下修饰的变量调用了autorelease方法.但是显示的使用__autoreleasing十分罕见,例如下面:</p>

<pre><code>@autoreleasepool{
  //持有非自己生成的对象
  id __strong obj = [NSMutableArray array];
  //因为obj是强引用,所以持有对象
  //因为该方法的类名array,所以将对象自动注册到autoreleasepool
}
//因为obj超出作用域,所以强引用失效
//因为autoreleasepool块的结束,所以其中的所有对象被释放,因为没有对象的所有者都不存在,所以被废弃
</code></pre>

<p>在ARC下作为函数的返回值,会被自动的注册到自动释放池中:</p>

<pre><code>+(id)array{
  return [[NSMutableArray alloc]init];
}
//在ARC下作为函数的返回值,会被自动的注册到自动释放池中


id __weak obj1 = obj0;
id __autoreleasing tmp = obj1;    //本句是自动添加的
NSLog(@"class is %@",[tmp class]);
</code></pre>

<h5>非显式的调用__autoreleasing</h5>

<p>1)函数的构造类方法,返回的对象被注册到自动释放池,例如[NSArray array];
2)在ARC下作为函数的返回值,会被自动的注册到自动释放池中
3)在访问有<strong>weak变量修饰的变量的时候,默认会将该对象注册到自动释放池中,因为此时对象有可能已经被废弃,要保证该内存在@autoreleasepool结束之前能够被访问.
4)id的指针 和 对象的指针都会被默认添加上</strong>autoreleasing修饰符.例如:NSError <em>* error;id</em> objPoint;</p>

<pre><code>-(BOOL)performOperationWithError:(NSError **)error;
&lt;!-- 等同于 --&gt;
-(BOOL)performOperationWithError:(NSError * __autoreleaseing *)error;
</code></pre>

<h5>显式的调用__autoreleasing</h5>

<p>1)显示调用的时候,必须要注意变量为局部变量,函数以及方法参数.不能作用于成员变量,全局变量等.
2)在LLVM3.0以上,ARC无效的时候,@autoreleasing块也能够使用.</p>

<h5>ARC规则</h5>

<p>1)不能使用retain/release/retainCount/autorelease
2)不能显式的调用dealloc</p>

<pre><code>不能直接调用,但是能够在类里面做一些自己需要的事情,例如从通知中心中清除注册者.
</code></pre>

<p>3)遵循内存管理的命名</p>

<pre><code>对于对象的生成和持有的方法,必须遵循下面的命名:alloc/new/copy/mutableCopy
以上述名称开始的方法返回对象的时候,必须返回调用方应当持有的对象.
使用init方法命名的对象更为严格,必须是实例方法,必须返回对象,返回的对象必须是id类型,或者该方法声明的类型,抑或是该类的超类或者子类型,该对象并不会
注册到autoreleasepool上,基本上是对象alloc的方法进行初始化.
</code></pre>

<p>4)使用@autoreleasepool 代替 NSAutoreleasePool
5)对象变量不能成为C语言结构体的成员</p>

<pre><code>虽然可以加上__unsafe_unretained让编译器通过编译,但是有内存泄漏和程序崩溃的风险.
</code></pre>

<p>6)显式转换的id 和 void*</p>

<p>在arc无效的时候,id和void*是可以直接转换的,并且不会产生问题,例如:</p>

<pre><code>id object = [[NSObject alloc]init];
void *object2 = object;     //id-&gt;void* 并不会产生问题

id object3 = object2;       //void*-&gt;id 并不会产生问题
[object3 release];
</code></pre>

<p>在arc有效中,可以直接通过添加__bridge来进行转换,但是这并不是安全的,形如:</p>

<pre><code>id obj = [[NSObject alloc]init];
void *p = (__bridge void *)obj;
id o = (__bridge id)p;
</code></pre>

<p>其还有另外两种的转换方式:<strong>bridge_retained 和 </strong>bridge_transfer
<strong>bridge_retained:使要转换赋值的变量也持有所赋值的对象.用于oc对象类型转换为c语言指针类型.其类似retain操作.
</strong>bridge_transfer:被转换的变量所有持有对象在该变量被赋值给转换目标后随之释放.用于c语言类型转换为oc对象类型,类似release操作.</p>

<p><strong>bridge：transfers a pointer between Objective-C and Core Foundation with no transfer of ownership.
</strong>bridge_retained、CFBridgingRetain：casts an Objective-C pointer to a Core Foundation pointer and also transfers ownership to you.
__bridge_transfer、CFBridgingRelease：moves a non-Objective-C pointer to Objective-C and also transfers ownership to ARC.</p>

<p>为什么字符串必须是copy呢?
答:It is still recommended to copy because you want to avoid something passing a mutable string and then changing it without you knowing. A copy guarantees that the string you have will not change.
如果你使用retain来修饰一个字符串,如果将来其发生了更改,你得到的值也会被更改,而你却并不知道,如果使用copy的话,这个值就永远不会更改了.</p>

<p>For attributes whose type is an immutable value class that conforms to the NSCopying protocol, you almost always should specify copy in your @property declaration. Specifying retain is something you almost never want in such a situation.</p>

<p>Here&rsquo;s why you want to do that:</p>

<pre><code>NSMutableString *someName = [NSMutableString stringWithString:@"Chris"];
Person *p = [[[Person alloc] init] autorelease];
p.name = someName;
[someName setString:@"Debajit"];
</code></pre>

<p>The current value of the Person.name property will be different depending on whether the property is declared retain or copy — it will be @&ldquo;Debajit&rdquo; if the property is marked retain, but @&ldquo;Chris&rdquo; if the property is marked copy.</p>

<p>Since in almost all cases you want to prevent mutating an object&rsquo;s attributes behind its back, you should mark the properties representing them copy. (And if you write the setter yourself instead of using @synthesize you should remember to actually use copy instead of retain in it.)</p>

<h4>属性声明和所有权对应关系</h4>

<p>assign &ndash;> <strong>unsafe_unretained
copy &ndash;> </strong>strong(但是赋值的是被复制的对象),并不是简单的赋值,他的赋值是通过NSCopying接口的copyWithZone:方法赋值源所生成的对象.
retain &ndash;> <strong>strong
strong &ndash;> </strong>strong
unsafe_unretained &ndash;> <strong>unsage_unretained
weak &ndash;> </strong>weak</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7人机交互指南笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji/"/>
    <updated>2014-02-19T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji</id>
    <content type="html"><![CDATA[<p>p10:
iOS 7 具体体现了以下主旨:
· 依从(Deference)。用户界面(UI)应当有助于用户理解内容并与之互动,而非对抗。
· 清晰(Clarity)。文字在每种字号下都易于阅读,图标表意准确清晰,装饰也恰到其度,并以对功能的无比关 注驱动设计。
· 纵深(Depth)。视觉上的分层界面和逼真的动作使其更赋活力,提升了用户的愉悦和理解。</p>

<p>p17:
拥抱无边框按钮。在 iOS 7中,所有的条栏按钮都没有边框。
如果合适,还可以通过显示纤细的边框或者浅 色背景来让按钮更加突出。</p>

<p>p26:
避免要求用户提供设置信息,代之以:
·关注 80% 用户的需求。这样,大部分用户不需要进行任何设置,因为你的 app 已经按他们期望的方式设置好了。如果有一些功能只有极少数用户可能需要或者大部分用户只会用一次,请抛弃这样的功能。
·尽可能通过其他方式获取信息。如果你可以使用任何内置程序或设备中用户所提供的信息,那就从系统中获取 这些信息,而不要让用户再输一次。
·如果你确实需要提供设置信息,请让人们在你的 app 中输入。然后,尽快存储这些信息(例如,在你 app 的 设置中)。这样一来,在有可能体验到你 app 的乐趣前人们不会被迫切换到 iOS 的「设置」中了。如果人们 将来需要修改这些信息,可以在任何时间前往 app 的设置页面进行修改。
尽可能将登录延后。最好在用户没有登录时就可以通过导航来浏览你的 app 并使用部分功能。用户在在可以做点有 用的事情前通常已经从那些强制他们登录的 app 中离开了。
一般来说,以设备的默认方向启动。在 iPhone 上,其默认方向是竖屏;在 iPad 上,则是设备当前的方向。如果你 的 app 只支持横屏,你应该始终以横屏方式启动,然后让用户在需要时旋转设备。
注意:对于只支持横屏的 app,最好能同时支持横屏竖屏两种状态,即 Home 键会在左侧或右侧的状态。如果设备 已经处于横屏,除非有很好的理由支持,否则只支持横屏的 app 应当就以此方向启动。另外,对只支持横屏的 app,Home 键应该在其右侧。(如需了解更多关于支持不同设备方向的信息,请参阅「响应设备方向的改变」(第 56页))
显示一个和 app 首屏极其相似的启动画面。iOS 会在你的 app 启动的瞬间显示这个启动画面,这可以让用户感觉你 的 app 非常快,并让你有足够的时间去加载内容。参阅「启动画面」(第 180 页)了解如何创建启动画面。
如果可能,避免在用户首次加载你的 app 时让他们阅读免责声明或确认终端用户许可协议。你可以让 App Store 显 示你的免责声明或者终端用户许可协议(EULA),以便人们可以在下载 app 前读到它们。如果你确实需要在 app 内展示这些东西,请确保以一种和 UI 保持和谐的方式将其整合进去,并在商业需求和用户体验间把握平衡。
App 重启后要恢复其状态,以便用户可以从中断的地方继续使用,而不要让用户去记住如何返回之前所在的位置。如 需了解更多关于高效重建和恢复 app 状态的方式,请参阅「State Preservation and Restoration」。</p>

<p>随时准备停止
iOS 应用永远不会显示一个「关闭」或「退出」选项。人们退出一个 app 的方式就是切换到另一个 app、返回主屏 幕或者让设备进入睡眠模式。
当人们从你的 app 切换离开,iOS 的多任务处理会将其挂到后台,并切换到新 app 的界面中。为了应对这种情况, 你应当:
·尽快并尽可能频繁地在合理范围内存储用户数据。这样做是因为处于后台的 app 随时都有可能被退出或结束。</p>

<p>启动和停止
随时准备停止,当 app 停止时,尽可能最多地保存当前状态的细节。这样的话,当人们切换回来时就不会失去之前所处的情 境。例如,如果你的 app 有显示可滚动的数据,那在停止时要保存当前所处的滚动位置。你可以前往「State Preservation and Restoration」了解更多关于高效重建和恢复 app 状态的方式。
有些 app 可能需要在用户运行其他 app 时一直在后台运行。例如,当用户在另一款 app 中检查待办事项或者玩游 戏时,他们会希望让正在播放音乐的 app 能继续播放。想要了解如何正确优雅地处理多任务,请参阅「多任务处 理」(第 84 页)。
永远不要以程序化的方式自动退出一个 iOS app。用户有可能会将其认为是程序崩溃了。如果由于一些可预知的问 题导致程序无法使用,那你需要告诉用户发生了什么、他们能做点什么。</p>

<p>p29:
给每个交互元素以足够的间距,以便用户对内容和控件进行操作。可点击控件的点击区域不小于 44 x 44 点。</p>

<p>p30:
将重要内容和功能放到更重要的位置,以便用户可以更容易地关注主要任务。一些可行的方法是,将主要元素放置在 屏幕的上半部分,并靠近屏幕左侧(基于从左至右的阅读习惯).</p>

<p>利用视觉上的权重和平衡来向用户显示界面元素之间的相对重要程度。相比尺寸较小的元素,那些大尺寸的元素更吸 引目光,看上去也更重要。</p>

<p>随时准备应对文字大小的变化。当用户在「设置」中更改文字大小时,他们会希望大多数的 app 可以作出合适的响 应。为适应一些文字字号的变化,你可能需要调整布局;如需了解关于在 app 中显示文字的更多信息,请参阅「文 字清晰易读」(第 49 页)。</p>

<p>p34:
永远要让用户知道自己正处于应用中的什么位置,并清楚如何去往他的下一个目标。</p>

<p>用导航栏来让用户在层级数据之间轻松穿梭。</p>

<p>用标签栏来展示平级分类的内容或功能。</p>

<p>用页码控件来指示有多个子项目或多屏内容。(页码控件?)</p>

<p>总的来说,最好是给用户以唯一的路径前往每个页面。</p>

<p>p37
用户对标准手势了如指掌</p>

<p>轻点(Tap) 用来按下或选中一个控件或项目</p>

<p>拖拽(Drag) 用来滚动或切换内容(即,从屏幕一边移动到另一边) 可以拖拽一个对象</p>

<p>滑动(Flick) 用来快速滚动或切换</p>

<p>轻扫(Swipe) 使用一只手指轻扫,可以返回上一个页面,可以显示在分栏视图 中的隐藏视图(仅 iPad),或表格视图里某行的「删除」按钮。在 iPad 上,四指轻扫可以在多个应用之间进行切换。
双击(Double tap) 用来放大内容或图片,并将其置于屏幕中央。 如果内容已被放大,则会将其缩小。
双指开合(Pinch) 双指张开或闭合以放大或缩小内容
长按(Touch and hold) 在可编辑或可选择的文本中会显示放大镜视图,用来 定位光标。</p>

<p>摇晃(Shake) 用来执行撤销或重做操作。</p>

<p>避免为标准手势赋予不同的行为</p>

<p>避免重复创建和标准手势具有相同行为的自定义手势</p>

<p>可以使用复杂手势作为完成任务的快捷方式,但不能是唯一的执行方式</p>

<p>通常,应避免定义新的手势,除非你的 app 是游戏</p>

<p>在 iPad 上,可以考虑使用多指手势</p>

<p>p41:
在内容区域,只在需要时为按钮添加边框或背景。(需要和内容性文字相区分)</p>

<p>p43:
尽可能在用户界面中整合状态和其他相关的反馈信息。(例如微信聊天列表的登录中…)
避免不必要的警告框。</p>

<p>使用选项来让用户输入变得轻松容易。例如,你可以使用选择器或者表格视图代替文本框,因为对大多数人来说,从 一个列表中找到并选中某一项比输入文字要容易。</p>

<p>适当时,从 iOS 获取信息。人们在他们的设备中存储了很多信息。如果你可以很容易地自己找到这些信息,那就不要 要求人们输入它们,例如他们的联系人或日历信息。</p>

<p>通过给予用户有用的信息来平衡信息输入的请求。(让用户觉得自己输入的信息是有用的)</p>

<p>p45:
如果合适,创建与内置动画效果相一致的自定义动画。</p>

<p>一般来说,要确保自定义动画真实可信。人们往往愿意接受外观上的艺术创新,但当他们体验到毫无意义或违背物理 规律的动态效果时仍然会感到怪异和困惑。例如,如果你通过在屏幕顶部往下滑动触发一个视图,你应当可以通过向 上滑动关闭这个视图,这样做有助于用户想起视图是从何而起。如果你通过在屏幕底部往下滑动来关闭同一个视图, 你会打破用户认为屏幕顶部存在可用视图的心智模型。</p>

<p>p49:
API 备注:如果需要给条栏按钮项目着色,请使用 tintColor 属性;若要给条栏本身着色,则使用 barTintColor 属性。</p>

<p>p50:
字体清晰易读</p>

<p>最为首要的是,文字必须清晰易读。如果用户根本看不清你的 app 中的文字,那字体设计得再漂亮也无济于事。在 iOS 7 app 中使用「动态字体」(Dynamic Type),可以实现:
· 自动调整每一种字体大小的字间距和行高
· 为不同语义的文本块指定不同的文本样式,例如正文、脚注或大标题
· 文字会适当响应用户对文字大小的设置更改(包括辅助功能中的文字大小)
注意:如果你在使用自定义字体,仍然可以根据系统设置的文字大小缩放字体。当用户改变设置,你的 app 要做出 适当的响应。
对你来说,使用「动态字体」可能需要一些工作量。如需了解如何使用文本样式并确保你的 app 在用户改变文字大 小设置时得到通知,请参阅《Text Programming Guide for iOS》中「Text Styles」一节。</p>

<p>在响应文字大小的变化时,优先让内容变化。</p>

<p>如果合适,在用户选择不同的文字大小时调整布局。</p>

<p>即便用户选择了最小文字大小,文字也不应小于 22 点。作为对照,正文样式在大字号下使用 34 点字体大小 作为默认文字大小设置。</p>

<p>p54:图像</p>

<p>支持 Retina 显示屏。确保你的 app 中所有的插图和图形元素都有提供 @2x 资源。
以原始宽高比显示照片和图形,且放大比例不超过 100%。你不会希望自己 app 中的差图和图形元素看上去失真或 过大。让用户自己选择是想要放大图像还是缩小图像。
不要在你的设计中使用 Apple 产品的复制图像。这些图像都是有版权的,而且这些产品设计会频繁变更。</p>

<p>p67:定义你的app
App 定义陈述是一份对 app 的主要目的及其目标用户简洁而具体的阐述。</p>

<p>1.列出所有你认为用户会喜欢的功能点
从这一步开始进行头脑风暴。你要尝试记下所有和你主要产品创意相关的任务。不要担心这个列表太长,稍后你会再 做筛选。</p>

<p>2.定义你的目标用户</p>

<p>经过思考这些问题,假设你确定了最符合你目标用户的三个特征:喜欢试验新菜谱、总是很忙、以及在不会太麻烦时 尽量节俭。</p>

<p>3.通过定义目标用户来筛选功能点
在确定了目标用户的特征之后,如果你得到了为数不多的几个特性,那就对了:优秀的 iOS app 都会精准聚焦于它 们所要帮助用户完成的任务。</p>

<p>当你不断在目标用户的情境中去验证特性清单,你就会领悟到你的 app 应该聚焦于三个主要特性:创建清单、获取 使用优惠券和发现食谱。</p>

<p>现在,你可以开始定义你的 app 了,具体地概括 app 是做什么用的以及给谁用。对于这个食物采购 app,一个好的 定义陈述可能是这样的:
「一个购物清单创建工具,为勤俭的美食家而生。」</p>

<p>4.继续向前
在整个开发过程中,始终要用你的app 定义陈述去判断功能点、控件和用词是否妥当。例如:
当你考虑增加一个新功能时,问问自己,这对你 app 的主要目的和目标用户是不是不可或缺?如果不是,把它放在 一边,它可能是构建另一个 app 的基础。例如,你已经确定你的用户喜欢探索烹饪,那么强调打包好的蛋糕和加工 好的熟食可能不会被用户喜欢。
当你考虑 UI 的外观和行为时,问问自己,你的目标用户是喜欢简洁流畅的设计,还是一个更明显的主题风格?以用 户对你 app 的期望为指引,例如使用 app 去完成一项重要任务,快速找到一个答案,探究内容详情,或者为了娱 乐。尽管你的购物清单 app 需要易于理解而且立即可以上手,但你的用户可能会更喜欢一个展示着大量美味食材图 片的界面主题。
当你在考量术语时,努力去迎合你的受众的专业认知。例如,即便你的受众不太可能由专业厨师组成,但你也应该明 白,用户会希望看到配方和技术方面的专业术语。</p>

<p>p79:原型和迭代</p>

<p>在你真正投入开发资源去完成你的设计前,创建一个原型去做用户测试会是很好的做法。即使你只能找到几个同事来 测试这些原型,你仍然会从他们对 app 功能的新鲜视角和体验中获益匪浅。</p>

<p>创建一个可信的原型最为简单的办法就是使用一个基于故事板(Storyboard-based)的 Xcode 模板去创建一个 基本 app,并填充一些合适的占位内容。</p>

<p>p161:</p>

<p>1.不要使用滑块去显示一个音量控件。如果你需要显示音量滑块,用 MPVolumeView 类去使用系统自带的音量滑块。 请注意,在当前激活的音频输出设备不支持音量控制时,音量滑块会被替换为适当的设备名称。</p>

<p>p180:
设计一个app 的第一屏一样的启动画面,如果你认为下面这些准则会导致一个朴素、无趣的启动图像,你说对了。请记住,启动画面并不是一个供你艺术表达 的机会。它的唯一目的是让用户认为你的 app 启动迅速并已准备就绪。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreAnimation随手记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/01/19/CoreAnimation/"/>
    <updated>2014-01-19T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/01/19/CoreAnimation</id>
    <content type="html"><![CDATA[<h1>0.关于核心动画</h1>

<p>CA会将打大部分的实际绘图工作交给绘图硬件,由绘图硬件来加速绘制.apple极力推荐你使用CA来构建iOS app的动画,因为这种自动绘制所产生的高帧率和光滑的动画,没有加重cpu的负荷,也没有令你的app运行缓慢</p>

<p>layer对象是用于管理和控制你内容的地方,在大多数app中,layer被用作于管理你试图内容的方法.layer对象会将你的内容转换为位图数据(bitmap),其能够被图形硬件更容易的控制.</p>

<p>layer对象很像view对象也包含bound,positon,opacity,transform以及其他的可视属性,常常当你更改这些属性的时候,会引起隐式的动画.</p>

<p>和view相似,layer也是具有层级结构的,它的层级结构影响显示的内容,你可以插入单个图层到层级中,用于拓展你app的显示.</p>

<p>action对象能够更改你layer定义的默认行为,隐式的动画是通过action对象实现的,你能够分配给你的aciton对象到layer的一个属性(无论是你增加的属性还是原有的属性),当这个属性更改的时候会触发aciton对象,从而产生动画.</p>

<h1>1.核心动画的基本概念</h1>

<p>layer并不是view的替代品,其是为了更好的展示,以及支持其内容动画的技术.layer提供了基本的绘制和动画,其是2d平面组织在3d空间的技术,和view的不同之处是,其并没有定义自己的外观,仅仅是管理周边位图的状态信息,在你的app中,最主要的layer常常是被看作是一个数据模型对象,就因为他是用来管理数据的,这个概念十分重要,因为它会影响动画的行为.</p>

<p>你app中的大多数layer并不做任何绘制的工作,仅仅是控制你app提供的内容,并将其缓存为位图数据.真正进行动画的是图形硬件,它使用bitmap和状态信息进行绘制,而CA只是制作和传递位图数据和状态信息.</p>

<p>layer绘制和view绘制是显著不同的,view绘制是通过调用其drawRect:方法进行重绘,这样的绘制是消耗巨大的,因为是使用cpu的主线程绘制.
但是CA是通过操作硬件中缓存的bitmap达到类似或者相同的结果,从而避免了高昂的代价.</p>

<p>更改图层的属性,能够引起适当的动画,具体的细节查看&#8221;Animatable Properties&#8221;章节,其主要会引起动画的行为:移动,缩放,旋转,透明度,圆角和背景颜色.</p>

<p>你只需要制定动画开始和结束的点,然后CA会在空闲的时候来做这个动画,并且你可以指定默认的时间信息和动画参数,CA还可以设置合适的默认值,如果你没有设置的话.</p>

<p>layer对象定义了自己的几何系统,layer和view也有很多不同的地方,例如锚点,以及一些几何相关的属性.</p>

<p>layer使用两种坐标系统:
基本点坐标系统和单元坐标系统</p>

<p>基本点坐标系统:当指定的值被直接映射到屏幕坐标中,或者必须被指定和其他图层有关系.例如position属性.</p>

<p>单元坐标系统:当值不能够被绑定到屏幕坐标中,因为其和其他的值是有关的,例如anchorPoint属性.我们将很少使用frame属性,因为其的值是从position和bounds衍生而来的.iOS中默认是从坐标系的左上角开始的,而OS X中默认是从左下角开始的.</p>

<p>anchorPoint的默认值是(0.5,0.5).</p>

<p>anchorPoint就相当于白纸上的图钉，它主要的作用就是用来作为变换的支点，旋转就是一种变换，类似的还有平移、缩放。anchorPoint的更改不会造成position的更改.anchor point是你旋转的支持点.当你更改anchor point旋转也会不同.</p>

<p>position就是anchorPoint在superLayer中的位置,但是更改不会影响anchorPoint</p>

<p>1、position是layer中的anchorPoint在superLayer中的位置坐标。
2、互不影响原则：单独修改position与anchorPoint中任何一个属性都不影响另一个属性,但是会影响Frame中origin的属性.</p>

<p>3、frame、position与anchorPoint有以下关系：</p>

<pre><code>frame.origin.x = position.x - anchorPoint.x * bounds.size.width；  
frame.origin.y = position.y - anchorPoint.y * bounds.size.height；
</code></pre>

<p>frame.origin由position和anchorPoint共同决定</p>

<p>(不够深入)
transfor属性将会影响当前的layer和其包含的sublayers,当你想要更改你自己的layer的时候使用这个属性
sublayerTransfor仅仅会影响sublayers,通常是增加一个透明的可视效果到情景内容上.</p>

<p>图层树反映出不同的动画状态:</p>

<p>模型树(model layer tree或者layer tree):大多数情况下它打交道,它中的对象是模型对象,并且保存了任何动画的目标值.当你更改layer的属性的时候,实际上使用的是其中的对象.</p>

<p>显示树(presentation tree ):永远都不要更改此树中的对象,一般是用于读取当前动画的值,可能用于创建一个新的动画.</p>

<p>渲染树(render tree):在此树上执行真正的动画,不能够直接的操作该树.</p>

<p>通过访问模型树的对象的presentationLayer属性,能够得到其在presentation tree相对应的对象,你可以通过这个对象获取动画过程中的值.</p>

<p>你只能在动画的执行过程中访问显示树的对象,当动画在进行中的时候,其和模型树的显示是不一样的,模型树总是呈现出动画的最终状态.</p>

<p>view仅仅是layer的细粒度包装,所以很多方法都可以直接设置到layer上,但是这样会产生不可以预料的结果.除了你view相对应的layer,你也可以创建独立的layer对象,并将其嵌入到你app中对象中.</p>

<p>你可以加载一次图片,然后让多个独立的layer对象以其关联,每一个图层都引用这张源图片,来替代创建这个图片的副本,从而节约内存空间.</p>

<h1>2.构建图层对象</h1>

<p>一般情况下,我们默认创建CALayer类的实例,只当你需要提升性能或者支持一种特殊类型的内容才需要创建其他类型的layer对象.我们可以通过重写view的layerClass方法,返回不同类型的layer对象,达到使用其他layer对象的目的,默认是CALayer对象,大部分情况下你不会改变.</p>

<pre><code>+ (Class) layerClass {
    return [CAEAGLLayer class];
}
</code></pre>

<p>不同的layer类提供了不同的试用场合:</p>

<p>CAEmitterLayer:Used to implement a Core Animation–based particle emitter system. The emitter layer object controls the generation of the particles and their origin.</p>

<p>CAGradientLayer:Used to draw a color gradient that fills the shape of the layer (within the bounds of any rounded corners).</p>

<p>CAEAGLLayer/CAOpenGLLayer:Used to set up the backing store and context needed to draw using OpenGL ES (iOS) or OpenGL (OS X).</p>

<p>CAReplicatorLayer:Used when you want to make copies of one or more sublayers automatically. The replicator makes the copies for you and uses the properties you specify to alter the appearance or attributes of the copies.</p>

<p>CAScrollLayer:Used to manage a large scrollable area composed of multiple sublayers.</p>

<p>CAShapeLayer:Used to draw a cubic Bezier spline. Shape layers are advantageous for drawing path-based shapes because they always result in a crisp path, as opposed to a path you draw into a layer’s backing store, which would not look as good when scaled. However, the crisp results do involve rendering the shape on the main thread and caching the results.</p>

<p>CATextLayer:Used to render a plain or attributed string of text.</p>

<p>CATiledLayer:Used to manage a large image that can be divided into smaller tiles and rendered individually with support for zooming in and out of the content.</p>

<p>CATransformLayer:Used to render a true 3D layer hierarchy, rather than the flattened layer hierarchy implemented by other layer classes.</p>

<p>我们一般通过三种方式提供layer的内容(位图):
1.直接指定一个image对象到layer对象的contents属性.(这是最好的办法,一般很少改变)
2.指定代理对象绘制layer的内容
3.定义了layer的子类,并且重写相关的绘制方法,自己提供内容</p>

<p>仅仅当你自己创建一个layer对象的时候,你才要但是为其提供内容.如果你使用的是layer-backed类型的view,你需不要但是layer的内容.当你使用一张图片做为layer的内容的时候,你可以将多个需要这张图片的layer都指向同一张图片,通过这种方式,你可以节约你app的内存空间.注意这里的图片必须是CGImageRef类型的.需要注意的是同一张图片在普通屏幕和视网膜屏幕,是不会自动设置,在视网膜屏幕下需要设置图片的contentsScale属性.一般图片设置为1,同时也是默认值,视网膜屏幕的图片需要设置该属性为2.</p>

<p>如果你layer的内容需要动态的改变,你可以使用delegate提供和更新你需要的内容,如果你的代理实现了displayLayer:方法,这个方法需要创建一个位图和指定layer的contents属性.如果你的代理实现了drawLayer:inContext:方法,CA创建了位图,并且创建了graphics context 用于绘制位图, 然后需要调用你的代理方法去填充位图,你的代理方法必须要做的就是在提供的graphics context中进行绘制.</p>

<p>你的代理必须实现displayLayer: 或者 drawLayer:inContext:,如果同时实现了那么只调用displayLayer:方法.下面是在不同的情况下加载不同图片的代码片段:</p>

<pre><code>- (void)displayLayer:(CALayer *)theLayer {
    // Check the value of some state property
    if (self.displayYesImage) {
        // Display the Yes image
        theLayer.contents = [someHelperObject loadStateYesImage];
    }
    else {
        // Display the No image
        theLayer.contents = [someHelperObject loadStateNoImage];
    } }
</code></pre>

<p>如果没有事先准备好的图片,那么可以调用drawLayer:inContext:绘制内容</p>

<pre><code>- (void)drawLayer:(CALayer *)theLayer inContext:(CGContextRef)theContext {
    CGMutablePathRef thePath = CGPathCreateMutable();
         CGPathMoveToPoint(thePath,NULL,15.0f,15.f);
         CGPathAddCurveToPoint(thePath,
                               NULL,
                               15.f,250.0f,
                               295.0f,250.0f,
                               295.0f,15.0f);
         CGContextBeginPath(theContext);
         CGContextAddPath(theContext, thePath);
         CGContextSetLineWidth(theContext, 5);
         CGContextStrokePath(theContext);
         // Release the path
         CFRelease(thePath);
     }
</code></pre>

<p>对于一个layer-backed的view来说,他会自动设置他的代理,并且实现他的代理方法,而我们需要做的是紧紧实现自己view的drawRect:方法.</p>

<p>如果你需要实现一个自定义的layer,你可以重写绘制方法,你可以使用下面两种方法中的一种来为你的layer提供内容:
1)重写display方法,然后直接的设置contents属性
2)重写drawInContext:方法,然后使用其提供的graphics context来进行绘制.</p>

<p>display方法是主要的方式用于更新你layer的内容,所以在这个方法中放入你完整的控制处理,重写这个方法同时意味着,你有责任创建CGImageRef类型的对象,并且只配给content属性,如果你只是想绘制内容或者是希望你的layer管理绘制的操作,你可以重写drawInContext:方法.</p>

<p>(注:Tweaking指的是小的更改来提高整个系统.)</p>

<p>当你为contents属性指定一张图片的时候,contentsGravity属性定义了图片是如何适配当前bounds的.默认情况下,如果图片或大,或小,layer对象将会拉伸图片以适应当前的bounds.</p>

<p>你指定到contentsGravity属性分为以下两种类型的值:
1)position_based gravity类型,并不拉伸你的图片,只是将你的图片防止在九宫格的某个位置.
2)scaling-based gravity类型, 有可能拉伸图片, 可以令图片适应bounds, 也可以令bounds适应图片.</p>

<p>layer还拥有自己的背景和边框,其主要分三层,底层是背景层,中间层是内容层,最上层是边框层.如果你需要将layer的背景颜色设置为一个非透明的颜色,可以设置opaque属性为YES,可以提升性能.如果你拥有一个圆角的话,记得不要设置layer为不透明的(opaque)属性.layer支持设置角落半径,因为其包含一个透明的遮罩,所以角落半径不能影响layer的contents属性的image,除非你设置了masksToBounds属性为YES,但是layer的背景颜色和border却可以根据角度半径而改变.</p>

<p>Layers还支持内置的阴影,他包含了多个属性来控制阴影,你可以控制阴影的颜色,相对的位置,不透明度和形状.需要设置显示阴影和阴影的位移,而且其是在layer的坐标系统中,并且OS X和 iOS还不同,需要注意区分.当你设置了masksToBounds属性,并且需要显示背影,背影会被裁剪,当你设置了任何透明的属性,可能会增加奇怪的效果,此时的解决方案是用两个layer代替一个,用一个layer1正常显示,用来拥有同等尺寸的layer的阴影,专门显示layer1的阴影.</p>

<p>CAAnimation和CALarer拓展了KVC,你可以添加数据到一个layer,并且关联一个由你定义的key,你甚至可以为你定制的属性关联action,当你更改这个属性的时候,一个事先定义的动画被执行</p>

<h1>3.使图层的内容产生动画</h1>

<p>隐式的动画使用默认的时间和动画属性去执行一个动画.
显式的动画需要你明确的使用动画对象去配置动画属性.
所以隐式的动画是简单的方式实现动画,并不需要编写很多代码.</p>

<p>触发隐式动画的唯一步骤就是更新你layer对象的能够产生动画的属性.如下所示:</p>

<pre><code>theLayer.opacity = 0.0;
</code></pre>

<p>你可以使用显式的动画创建同样的效果,例如:</p>

<pre><code>CABasicAnimation* fadeAnim = [CABasicAnimation animationWithKeyPath:@"opacity"];
fadeAnim.fromValue = [NSNumber numberWithFloat:1.0];
fadeAnim.toValue = [NSNumber numberWithFloat:0.0];
fadeAnim.duration = 1.0;
[theLayer addAnimation:fadeAnim forKey:@"opacity"];
// Change the actual data value in the layer to the final value.
// 更改这个动画属性会再次触发隐式的动画,文章的后面会讲解如何更改隐式的动画
theLayer.opacity = 0.0;
</code></pre>

<p>使用显式的动画的时候,需要指定动画的初始值,如果没有指定的话,那么当前值就被当作是初始值,如果你已经更新layer的属性为最终值,可能造成你意想不到的结果.与隐式的动画不同的是,显示动画并不会更改layer的属性值,而仅仅是进行动画,你需要手动的更新你动画的属性值.
显式动画和隐式动画必须在当前的运行循环结束后执行.你可以同一时刻执行两种动画,例如位移和更改透明度同时执行,并且你还可以让一个动画在特定的时间执行.</p>

<p>使用Keyframe Animation更改layer的属性 ,可以设定一组目标值 ,并且这些值可以是线性或者非线性的.</p>

<p>例如下面的例子演示了,为layer对象的每一帧动画指定的postion.完整的代码例子,请参阅文章末尾的项目源码.</p>

<pre><code>// create a CGPath that implements two arcs (a bounce)
 CGMutablePathRef thePath = CGPathCreateMutable();
 CGPathMoveToPoint(thePath,NULL,74.0,74.0);
 CGPathAddCurveToPoint(thePath,NULL,74.0,500.0,
                                    320.0,500.0,
                                    320.0,74.0);
 CGPathAddCurveToPoint(thePath,NULL,320.0,500.0,
                                    566.0,500.0,
                                    566.0,74.0);
 CAKeyframeAnimation * theAnimation;
 // Create the animation object, specifying the position property as the key path.
 theAnimation=[CAKeyframeAnimation animationWithKeyPath:@"position"];
 theAnimation.path=thePath;
 theAnimation.duration=5.0;
 // Add the animation to the layer.
 [theLayer addAnimation:theAnimation forKey:@"position"];
</code></pre>

<p>往往关键帧的值是一组对象,你需要将基本类型包装为对象类型,需要遵循以下的规则:</p>

<pre><code>CGRect-&gt;NSValue
CATransform3D-&gt;NSValue
在borderColor属性中:CGColorRef-&gt;id
CGFloat-&gt;NSNumber
在contents属性中:CGImageRef
</code></pre>

<p>于此同时你还需要指定关键帧的时间,你可以形象的理解为动画片的原理,是由一张一张图片构建而成,keyTimes的值是一个数组,其中的值都是小于等于1的浮点型,这个数组必须以0.0开始, 例如其中有4帧的动画,keyTimes数组中的元素为:应该是NSNumber类型
[0.0,0.25,0.5,0.75,1.0];其中相邻的两个时间点的元素是该珍动画的执行时间,一般以0.0开始1.0结束.</p>

<p>有时你还需要设置calculationMode属性来使用不同的动画计算法则:</p>

<pre><code>1)线性和立体:设置为kCAAnimationLinear和CAAnimationCubic

2)同步的动画设置为:始终如一的速度不受keyTime和timingFuncitons属性的影响
kCAAnimationPaced
kCAAnimationCublicPaced

3)分离的动画设置为:
kCAAnimationDiscrete,这时候按照keyImes属性指定的时间,但是忽略timingFunctions属性.

4)keyTimes属性指定了没一帧动画需要的时间,只有当calculationMode设置为kCAAnimationLinear, kCAAnimationDiscrete, 或者 kCAAnimationCubic
才会起作用.

5)timingFunction属性制定了时间曲线,为每个关键帧的片段指定时间.

6)如果你想自己指定时间,需要使用kCAAnimationLinear或者kCAAnimationCubic模式,并在keyTimes和timingFunctions属性中指定.如果你没有指定timing funcitons,那么整个动画是线性的.
</code></pre>

<p>停止一个正在运行的动画:</p>

<pre><code>1)通过调用removeAnimationForKey:方法,这个key就是你addAnimation:forKey:指定的key.
2)移除所有的动画:removeAllAnimations
</code></pre>

<p>如果动画在显示的时候突然被停止,CA会使用当前值重绘layer,但是一般当前值是动画的最终值,所以动画可能会产生突然的跳转,你可以通过presentation tree获取动画被打断时候值 ,然后设置到layer tree,就会避免这种情况.</p>

<p>当你需要多个动画一起作用的时候,你需要使用CAAnimationGroup对象,下面的例子演示了同时执行同等长度的两个动画:</p>

<pre><code>  // Animation 1
  CAKeyframeAnimation* widthAnim = [CAKeyframeAnimation animationWithKeyPath:@"borderWidth"];
  NSArray* widthValues = [NSArray arrayWithObjects:@1.0, @10.0, @5.0, @30.0, @0.5,
  @15.0, @2.0, @50.0, @0.0, nil];
  widthAnim.values = widthValues;
  widthAnim.calculationMode = kCAAnimationPaced;
  // Animation 2
  CAKeyframeAnimation* colorAnim = [CAKeyframeAnimation
  animationWithKeyPath:@"borderColor"];
  NSArray* colorValues = [NSArray arrayWithObjects:(id)[UIColor greenColor].CGColor, (id)[UIColor redColor].CGColor, (id)[UIColor blueColor].CGColor, nil];
  colorAnim.values = colorValues;
  colorAnim.calculationMode = kCAAnimationPaced;
  // Animation group
  CAAnimationGroup* group = [CAAnimationGroup animation];
  group.animations = [NSArray arrayWithObjects:colorAnim, widthAnim, nil];
  group.duration = 5.0;
  [myLayer addAnimation:group forKey:@"BorderChanges"];
</code></pre>

<p>这里有一个更高级的方式去让一组动画一起工作,这就是使用transaction对象,使用transaction对象能够提供更多的灵活性,可以提供嵌套的动画,并且为每个不同的动画指定不同的参数.</p>

<p>有的时候你需要检测动画的结束:</p>

<pre><code>1&gt;当你使用transaction对象的时候,设置setCompletionBlock:方法,当所有事务中所有动画执行完成后会调用.
2&gt;设置CAAnimation的代理对象,并且实现其代理方法监测.
</code></pre>

<p>但是当你想要在一个动画A结束后开始动画B,你不要使用动画的通知(block或者delefate),而是使用beginTime属性来取代.</p>

<p>如果一个layer属于layer-backed view的,那么被推荐的做法是使用在UIKit中定义的view_based 动画接口,你也可以使用CA接口,但是按照下面的方法来设置动画.
当你为一个view-based设置动画的时候,需要在view的block中设置动画,而block外边的动画设置会被忽略的.下面的例子中制定了两个动画:</p>

<pre><code>1)隐式的动画按照默认的时间执行
2)CABaseAnimation按照指定的时间执行
3)block外边的时间设置被忽略.
</code></pre>

<p>示例代码如下所示:</p>

<pre><code>[UIView animateWithDuration:1.0 animations:^{
   // Change the opacity implicitly.
   myView.layer.opacity = 0.0;
// Change the position explicitly.
CABasicAnimation* theAnim = [CABasicAnimation animationWithKeyPath:@"position"];
   theAnim.fromValue = [NSValue valueWithCGPoint:myView.layer.position];
   theAnim.toValue = [NSValue valueWithCGPoint:myNewPosition];
   theAnim.duration = 3.0;
   [myView.layer addAnimation:theAnim forKey:@"AnimateFrame"];
}];
</code></pre>

<h1>4.建立图层的层级结构</h1>

<p>大多数情况下,最好的方法使用layer是控制其对应的view对象,当你使用layer能够提供更好的性能或者实现一个使用view难以实现的功能的时候,你需要构建view的层级结构.</p>

<p>layer对象拥有一系列的方法来更改来进行layer的添加,插入和移出操作,你只能将其用到你自己创建的layer上,对于layer-backed view,你并不能使用这些方法来更改layer的顺序,但是其能够扮演你layer父亲的角色.</p>

<p>你可以设置sublayer的位置和大小,通过bound属性和positon属性,用frame属性也是可以的,其默认值都是0.layer的宽度和高度都最好设置为整形.speed属性默认值是1,会影响layer的动画速度,如果设置为2,那么会运行两次,每次是原来时间的一半,如果sublayer也设置了这个属性为2,那么subview就会运行4次,他们之间是一个乘法关系.大多数layer的更改是可以预料到的,例如你旋转一个layer,你所有的子layer都会被旋转,你更改一个layer的位置,所有的子layer都会变化.</p>

<p>layer级别的显示只有当你使用单个layer构造的layer层级结构才有有作用,如果使用的是view_backed layer通过改变view来改变layer.</p>

<p>在iOS中你可以手动的处理布局,通过实现superlayer的代理对象的layoutSublayersOfLayer:方法.如果你实现了一个自定义的layer的子类,你的子类可以重写layoutSublayers方法,而且使用这些方法去处理任何layer相关的任务,你仅仅需要重写这些方法在你需要完成你sublayer在你的自定义layer类内部的布局的时候.</p>

<p>与view不同的是,superlayer不会自动裁剪你sublayer展示在superlayer矩形区域外的内容,你需要自己设置maksToBounds属性为YES.</p>

<p>当你需要在两个layer坐标系统中转换坐标的时候,其提供了一组方法:</p>

<pre><code>1.convertPoint:fromLayer:
2.convertPoint:toLayer:
3.convertRect:fromLayer:
4.convertRect:toLayer:
</code></pre>

<p>与此同时还定义了同步时间的方法:
convertTime:fromLayer: 和 convertTime:toLayer:
每一个layer定义了属于自己的本地时间空间,并且在系统闲置的时候,同步动画的开始和结束时间.
但是当你更改了一组layer的时候,这些layer的时间空间就被改变了.所以你可以使用上述的方法来确保两个layer的时间是同步的.</p>

<h1>5.高级动画技巧</h1>

<h2>CATransition</h2>

<p>这里有很多的方法去控制你的基本属性动画和keyframe动画,当你的app需要执行多个动画在一起,从而使用更多的高级行为,同步
那些动画的时间或者将他们连在一起.你可以使用其他类型的动画创建一个可视的过渡效果,或者其他的有趣的动画效果.</p>

<p>在显示一个layer的时候,隐藏一个layer,这种情况下使用Transition Animations十分合适,
CATransition可以创建一个动画的过度效果,下面是一个在两个view间产生过渡效果的例子:</p>

<pre><code>  CATransition* transition = [CATransition animation];
  transition.startProgress = 0;
  transition.endProgress = 1.0;
  transition.type = kCATransitionPush;
  transition.subtype = kCATransitionFromRight;
    transition.duration = 1.0;
    // Add the transition animation to both layers
    [myView1.layer addAnimation:transition forKey:@"transition"];
    [myView2.layer addAnimation:transition forKey:@"transition"];
    // Finally, change the visibility of the layers.
    myView1.hidden = YES;
    myView2.hidden = NO;
</code></pre>

<p>有时候你还需要明确的控制时间,这时候你需要通过CAMediaTiming协议来明确精确的控制时间.</p>

<p>CAAnimation类包含了这个协议,所以你可以指定时间信息到你动画对象.</p>

<p>CALayer也包含了这个协议,你可以配置
时间相关的属性在隐式的动画里,通过这些隐式的动画对象,你可以包装这些动画,让其使用你设定的时间值.</p>

<p>每一个layer都有自己的本地时间,但是由于图层间的时间十分相近,所以不容易被用户察觉,但是图层的本地时间能够被其父图层或者是自己的时间参数更改,例如更改layer的speed属性.</p>

<p>为了确定给合适的layer准确的额时间,所以其提供了两个方法用于时间转换,你可以用于:
1.将一个固定的时间值转换到一个layer上.
2.将一个layer的本地时间用于另一个layer.</p>

<p>CACurrentMediaTime()f方法可以获取计算机当前时钟的时间,下面的例子演示了具体的用法:</p>

<pre><code>CFTimeInterval localLayerTime = [myLayer convertTime:CACurrentMediaTime()
fromLayer:nil];
</code></pre>

<p>当在你的layer的本地时间内,你拥有了一个时间值,你就可以更改时间相关的属性了,例如beginTime属性.
延迟一个动画的开始时间的时候,需要设置fillMode属性为kCAFillModeBackwards,不然有可能造成动画跳跃式的显示.
autoreverses属性的设置导致动画执行在一个特定的时间里面并且返回动画的开始值.你可以配合repeatCount属性结束的时候在其结束值.
timeOffset属性用于在执行某些动画在稍后的时间里.</p>

<p>当你需要停止一个动画的时候,首先将该layer的speed设置为0,其次是设置layer的timeOffset的时间为当前的时间,
当你需要恢复一个动画的时候,首先设置layer的speed为1.0,其次设置layer的timeOffset为0,最后获取该layer的当前时间 减去 其暂停的时间 就是layer的开始时间.</p>

<p>具体的代码片段如下所示:</p>

<pre><code>-(void)pauseLayer:(CALayer*)layer {
     CFTimeInterval pausedTime = [layer convertTime:CACurrentMediaTime()
  fromLayer:nil];
     layer.speed = 0.0;
     layer.timeOffset = pausedTime;
  }
  -(void)resumeLayer:(CALayer*)layer {
     CFTimeInterval pausedTime = [layer timeOffset];
     layer.speed = 1.0;
          layer.timeOffset = 0.0;
          layer.beginTime = 0.0;
          CFTimeInterval timeSincePause = [layer convertTime:CACurrentMediaTime()
       fromLayer:nil] - pausedTime;
          layer.beginTime = timeSincePause;
   }
</code></pre>

<p>关于当前的时间(pausedTIme)timeoffset和begintime:</p>

<p>pausedTIme:是该动画的总共时间.例如100,这个数字是递减的
timeoffset:动画的起点
beginTime:是指其父级对象的时间线上的某个时间,默认是0,所以代码中设置的开始时间已经执行过的时间.</p>

<h2>Transaction</h2>

<p>明确的事务(Transaction)令你更改动画的参数
任何你对一个layer的更改必须是事务的一部分,CATransaction类管理动画的分组和创建,以及他们在恰当的时间执行,你没有必要去创建自己的事务,CA为你的显式和隐式的动画默认创建了事务,当然你也可以显式的创建一个事务,来更加细粒度的控制动画.</p>

<p>当你创建和管理事务的时候,需要使用CATransaction类的方法,一个新的事务在begin方法后开始,在commit方法后结束,在这张两个方法之中,你可以做一些你想对事务的更改:</p>

<pre><code>[CATransaction begin];
theLayer.zPosition=200.0;
theLayer.opacity=0.0;
[CATransaction commit];
</code></pre>

<p>创建一个显示的transaction动画的主要原因是,你需要改变duraction,timing function,或者其他的参数,当你transaction中的一组动画完成的时候,你还可以指定一个完成的block,另外你还可以更改动画所必须的参数,使用setValues:forKey:方法更改transaction字典中必要的key.</p>

<pre><code>[CATransaction begin];
[CATransaction setValue:[NSNumber numberWithFloat:10.0f]
                  forKey:kCATransactionAnimationDuration];
 // Perform the animations
 [CATransaction commit];
</code></pre>

<p>当你想要为不同组的动画提供不同的参数的时候,你可以嵌套使用transaction来进行构建.在一个transaction中构建另一个transaction,你需要再次调用beigin方法,与其对应的是,你还需要调用commit方法.只要当你最外层的transaction动画被commit了,整个CA才开始执行动画.下面是一个嵌套事务的例子:</p>

<pre><code>[CATransaction begin]; // Outer transaction
// Change the animation duration to two seconds
[CATransaction setValue:[NSNumber numberWithFloat:2.0f]
                forKey:kCATransactionAnimationDuration];
// Move the layer to a new position
theLayer.position = CGPointMake(0.0,0.0);
[CATransaction begin]; // Inner transaction
// Change the animation duration to five seconds
[CATransaction setValue:[NSNumber numberWithFloat:5.0f]
                 forKey:kCATransactionAnimationDuration];
// Change the zPosition and opacity
theLayer.zPosition=200.0;
theLayer.opacity=0.0;
[CATransaction commit]; // Inner transaction
[CATransaction commit]; // Outer transaction
</code></pre>

<h1>6.更改图层的默认行为</h1>

<h2>CAAction</h2>

<p>CA实现他的隐式动画通过使用action对象,一个action对象是遵循CAAction协议的,其定义了一些执行在layer上的相关的行为,所有的CAAnimation对象都实现了这个协议,当一个layer的属性更改的时候,这些对象能够被执行.
动画属性是一类action,你几乎能够通过定义这些action实现你想要的任何效果:</p>

<pre><code>1)定义你的action对象
2)让他们和你app的layer对象相关联
</code></pre>

<p>自定义action对象需要遵循了CAAction协议,通过实现CAAction协议的runActionForKey:object:arguments:方法,在这个方法里增加可视的信息去执行,你可以在这方法里面添加动画对象到layer上或者是用这个方法去执行其他的任务.</p>

<p>当你定义好了一个action对象,你必须指定是如何触发的,这个action为触发定义了一个key,你可以通过以下方式来触发:</p>

<pre><code>1.layer的属性值发生了改变,他能够设置为layer的任何属性(并不仅仅和动画相关的),标记到这个action的key就是该属性的名字.
2.这个layer变得可视或者被添加到layer层级中,这个action被定义的key需要命名为kCAOnOrderIn.
3.一个layer将要从layer的层级结构中移出,key需要定义为KCAOnOrderOut.
4.这个图层被包含在一个transition动画中,key需要被定义为kCATransiton.
</code></pre>

<p>Action对象必须要被添加到一个layer上,才可以产生作用,CA通过以下的顺序查找action对象:</p>

<p>1.如果layer有代理并且实现了actionForLayer:forKey:方法,你必须实现了下述中的其中一条:</p>

<pre><code>1)返回对应key的action对象
2)返回nil,搜索会继续向下进行
3)返回NSNull对象,搜索终止.
</code></pre>

<p>2.查找layer的actions字典.
3.查找layer的style字典.
4.调用defaultActionForKey:方法
5.如果CA定义了该key的隐式的action,那么执行.</p>

<p>当layer发现了action对象,就会调用这个对象的runActionForKey:object:arguments:方法,去执行这个action,如果这个action已经定义一个CAAnimation类存在key,你可以使用该方法默认的实现.</p>

<p>如果你定义了你自己的自定义对象,并且遵循CAAction协议,你必须在那个方法中使用你的对象的实现.</p>

<p>你的action对象在什么地方装配,取决于你想要怎样的更改你的layer:</p>

<pre><code>1.如果这个action对象仅仅出现在特殊的情况下,或者layer已经在代理中使用过了,需要通过实现actionForLayer:forKey:方法.
2.layer对象并不经常使用代理的话,添加这个action到你layer的actions字典中.
3.如果是你自己定义的属性在layer对象中的话,把action添加到style字段中.
4.如果这个action是layer的默认行为,那么子类化layer,并且重写defaultActionForKey:方法.
</code></pre>

<p>这里演示了如果监测contents属性的默认动画,并且更改其实现的方法.</p>

<pre><code>- (id&lt;CAAction&gt;)actionForLayer:(CALayer *)theLayer
                        forKey:(NSString *)theKey {
    CATransition *theAnimation=nil;
    if ([theKey isEqualToString:@"contents"]) {
        theAnimation = [[CATransition alloc] init];
        theAnimation.duration = 1.0;
        theAnimation.timingFunction = [CAMediaTimingFunction
functionWithName:kCAMediaTimingFunctionEaseIn];
        theAnimation.type = kCATransitionPush;
        theAnimation.subtype = kCATransitionFromRight;
    }
    return theAnimation;
}
</code></pre>

<p>每当你改变一个layer的属性,CA通常创建了隐式的transaction对象去展示这些改变,你可通过设置kCATransactionDisableActions为true来使得默认动画失效,下面是让移除动画失效的方法:</p>

<pre><code>  [CATransaction begin];
  [CATransaction setValue:(id)kCFBooleanTrue
                   forKey:kCATransactionDisableActions];
  [aLayer removeFromSuperlayer];
  [CATransaction commit];
</code></pre>

<h1>7.提升图层性能</h1>

<p>CA是一种很棒的方式去提高帧率,但是并不能保证性能.尤其是在OS X中,下面是使你的动画更加有效率的几种方式:</p>

<pre><code>1.当必要的时候使用透明的layer.
2.为CAShapeLayer使用简单的路径.
3.为显示相同的layer明确设置同一个的内容.
4.总是为layer的size 属性设置为整形值.
5.在需要的时候使用异步的图层
6.设置shadowPath属性,当你为你的layer添加一个背影的时候.
</code></pre>

<h1>8.图层风格属性动画</h1>

<h2>几何属性</h2>

<p>几何属性定义了layer相对于其父layer是如何显示的,其主要包含下面的属性:</p>

<pre><code>bounds
position
frame
anchorPoint
cornetRadius
transform
zPosition
</code></pre>

<h2>背景属性</h2>

<pre><code>backgroundColor
</code></pre>

<h2>图层的内容</h2>

<pre><code>contents
contentsGravity
masksToBounds
</code></pre>

<h2>子图层的内容</h2>

<pre><code>sublayers
masksToBounds
sublayerTransform
</code></pre>

<h2>边框属性</h2>

<pre><code>borderColor
borderWidth
</code></pre>

<h2>阴影属性</h2>

<pre><code>shadowColor
shadowOffset
shadowOpacity
shadowRadius
shadowPath
</code></pre>

<h2>透明度属性</h2>

<pre><code>opacity
</code></pre>

<h2>遮罩属性</h2>

<p>你能够通过该属性模糊你layer的一部分内容,或者所有的内容.</p>

<pre><code>mask
</code></pre>

<h1>9.能够产生动画的属性</h1>

<p>当你更改下列这些属性的时候,将会引起默认的动画:</p>

<pre><code>anchorPoint
backgroundColor
backgroundFilters
borderColor
borderWidth
bounds
compositingFilter
contents
contentsRect
cornerRadius
doubleSided
filters
frame
hidden
mask
masksToBounds
opacity
position
shadowColor
shadowOffset
shadowOpacity
shadowPath
shadowRadius
sublayers
sublayerTransform
transform
zPosition
</code></pre>

<h1>10.KVC的拓展</h1>

<p>CA拓展了NSKeyValueCoding协议,适用于CAAnimation和CALayer类,这样的拓展为一些key增加了默认的行为,
支持了CGPoint,CGRect,CGSize和CATransform3D类型.</p>

<p>对于CAAnimation和CALayer类,你可以为其任意的属性设置值,包含那些你自己定义的属性,例如:</p>

<pre><code>[theLayer setValue:[NSNumber numberWithInteger:50] forKey:@"someKey"];
</code></pre>

<p>你可以通过下面的方法获取到你设置的值:</p>

<pre><code>someKeyValue=[theLayer valueForKey:@"someKey"];
</code></pre>

<p>你还可以为那些没有设置默认值的key指定一个默认值,通过子类化当前类,并且重写defaultValueForKey:方法,无论是自己定义的属性还是自己添加的属性,你都是可以更改的.</p>

<pre><code>+ (id)defaultValueForKey:(NSString *)key
{
    if ([key isEqualToString:@"masksToBounds"])
         return [NSNumber numberWithBool:YES];
    return [super defaultValueForKey:key];
}
</code></pre>

<p>你可以把一些基本类型包装成对象类型,只需要遵循下面的约定:</p>

<pre><code>CGPoint-&gt;NSValue
CGSize-&gt;NSValue
CGRect-&gt;NSValue
CATransform3D-&gt;NSValue
</code></pre>

<p>对结构体数据访问的支持,在CAAnimation 和 CALayer中,你可以通过使用setValue:forKeyPath: 和 valueForKeyPath: 两个方法对其结构体属性的数据进行访问和设置,其包含以下这些属性:</p>

<pre><code>rotation.x
rotation.y
rotation.z
rotation
scale.x
scale.y
scale.z
scale
translation.x
translation.y
translation.z
translation
</code></pre>

<p>使用方法,如下面的例子所示:</p>

<pre><code>[myLayer setValue:[NSNumber numberWithFloat:10.0]
forKeyPath:@"transform.translation.x"];
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[idep账号激活成功]]></title>
    <link href="http://MonaDogg.github.io/blog/2013/12/13/first-idep-app/"/>
    <updated>2013-12-13T10:36:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2013/12/13/first-idep-app</id>
    <content type="html"><![CDATA[<p>点击<a href="itms-services://?action=download-manifest&amp;url=http://monadogg.github.io/ipa/newZuzhili.plist">这里</a>安装组织力.</p>

<p>点击<a href="itms-services://?action=download-manifest&amp;url=http://www.zuzhili.com/app/app.plist">这里2</a>安装组织力.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[越狱开发随手记]]></title>
    <link href="http://MonaDogg.github.io/blog/2013/12/03/yue-yu-kai-fa-xiang-guan-bi-ji/"/>
    <updated>2013-12-03T11:12:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2013/12/03/yue-yu-kai-fa-xiang-guan-bi-ji</id>
    <content type="html"><![CDATA[<h2>1安装iOS sdk</h2>

<p>Step1:安装iOS SDK.</p>

<h2>2下载theos</h2>

<p>可以简单理解theos为越狱开发的环境</p>

<pre>
export THEOS=/opt/theos
//设置环境变量
svn co http://svn.howett.net/svn/theos/trunk $THEOS
//svn下载相关内容到位置
</pre>


<p>可以使用下列语句打印看看:</p>

<pre>
echo $THEOS
</pre>


<h2>3下载ldid</h2>

<p>ldid的功能是给app签名
下载并解压到桌面上: <a href="http://cloud.github.com/downloads/rpetrich/ldid/ldid.zip">http://cloud.github.com/downloads/rpetrich/ldid/ldid.zip</a></p>

<pre>
chmod +x ~/Desktop/ldid
//设置ldid可以执行的权限

mv ~/Desktop/ldid $THEOS/bin/ldid
//将ldid移动到指定的位置
</pre>


<h2>4安装MacPorts和dpkg</h2>

<p>1.先安装Macports,选择合适的系统版本,有可能会卡在最后一分钟，需要重启后断网安装即可。</p>

<p>2.dpkg的作用是将你的app打包为debian paceage.
sudo port install dpkg</p>

<h2>5创建一个新的项目</h2>

<p>theos使用一个叫做nic(new instance tool)的工具来创建新的工程。执行下面的命令：
$THEOS/bin/nic.pl
就可以开始创建。</p>

<p>下面是一个创建jailbroken 应用程序的例子：</p>

<pre>
author$ $THEOS/bin/nic.pl
NIC 1.0 - New Instance Creator
——————————
  [1.] iphone/application
  [2.] iphone/library
  [3.] iphone/preference_bundle
  [4.] iphone/tool
  [5.] iphone/tweak
Choose a Template (required): 1
Project Name (required): firstdemo
Package Name [com.yourcompany.firstdemo]: 
Author/Maintainer Name [Author Name]: 
Instantiating iphone/application in firstdemo/…
Done.
</pre>


<p>这样就会在当前目录下创建一个名为fistdemo的文件夹</p>

<h2>6生成文件说明</h2>

<p>1.control: 包含applicaton/tweak的信息，当你从Cydia安装时，你可以看到这些信息，包括名字，作者，版本，等等。</p>

<p>2.main.m，程序启动的入口.</p>

<p>3.firstDemoApplication:app的代理文件类</p>

<p>4.Makefile：包含必要的编译命令</p>

<p>5.Resources：包含info.plist文件等</p>

<p>6.RootViewController.h/mm :根vc
其中Makefile的内容为:</p>

<pre>
include theos/makefiles/common.mk

APPLICATION_NAME = firstDemo
firstDemo_FILES = main.m firstDemoApplication.mm RootViewController.mm
firstDemo_FRAMEWORKS = UIKit CoreGraphics

include $(THEOS_MAKE_PATH)/application.mk
</pre>


<h2>7重新设置环境变量</h2>

<p>设置下列环境变量:环境位置,sdk版本,设备ip地址.</p>

<pre>
export THEOS=/opt/theos/
export SDKVERSION=7.0
export THEOS_DEVICE_IP=xxx.xxx.xxx.xxx
</pre>


<h2>8构建工程</h2>

<p>1.make</p>

<pre>
$ make
Making all for application firstdemo…
 Compiling main.m…
 Compiling firstdemoApplication.mm…
 Compiling RootViewController.mm…
 Linking application firstdemo…
 Stripping firstdemo…
 Signing firstdemo…
</pre>


<p>
2.make package</p>

<pre>
make package
Making all for application firstdemo…
make[2]: Nothing to be done for ‘internal-application-compile’.
Making stage for application firstdemo…
 Copying resource directories into the application wrapper…
dpkg-deb: building package ‘com.yourcompany.firstdemo’ in ‘/Users/author/Desktop/firstdemo/com.yourcompany.firstdemo_0.0.1-1_iphoneos-arm.deb’.
</pre>


<p>3.make install 执行次操作之前确保iPhone安装了OpenSSH,并且在同一局域网.</p>

<pre>
$ make package install
Making all for application firstdemo…
make[2]: Nothing to be done for `internal-application-compile’.
Making stage for application firstdemo…
 Copying resource directories into the application wrapper…
dpkg-deb: building package ‘com.yourcompany.firstdemo’ in ‘/Users/author/Desktop/firstdemo/com.yourcompany.firstdemo_0.0.1-1_iphoneos-arm.deb’.
...
root@ip’s password: 
...
</pre>


<p>这个过程会提示你输入几次iphone或者ipad的密码。默认是:alpine.</p>

<h2>9.构建一个Tweak</h2>

<p>本文介绍如果hook ios中任意类的方法的例子.</p>

<p>1.下载libsubstrate.dylib到/opt/theos/lib.</p>

<p>2.class-dump相关头文件到/opt/theos/include目录下</p>

<p>3.创建tweak项目
执行 $THEOS/bin/nic.pl,选择5</p>

<pre>
author$ $THEOS/bin/nic.pl
NIC 1.0 - New Instance Creator
——————————
  [1.] iphone/application
  [2.] iphone/library
  [3.] iphone/preference_bundle
  [4.] iphone/tool
  [5.] iphone/tweak

Choose a Template (required): 5
Project Name (required): WelcomeWagon 
Package Name [com.yourcompany.welcomewagon]: 
Author/Maintainer Name [Brandon Trebitowski]: 
MobileSubstrate Bundle filter [com.apple.springboard]: 
Instantiating iphone/tweak in welcomewagon/…
Done.
</pre>


<p>4.改写Tweak.xm文件
一旦你创建了项目，你会发现Theos生成了一个叫做Tweak.xm的文件，这是个特殊的文件，hook的相关代码就将写在这个文件。</p>

<pre>
#import 
//引入相关的dump出的头文件

%hook SpringBoard
//hook的类名

-(void)applicationDidFinishLaunching:(id)application {
%orig;
//执行原方法

UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Welcome" 
message:@"Welcome to your iPhone Brandon!" 
delegate:nil 
cancelButtonTitle:@"Thanks" 
otherButtonTitles:nil]
[alert show];
[alert release];
}
//新增的hook代码

%end
//代码结束
</pre>


<p>5.更改makefile文件,加入相关的类库</p>

<p>WelcomeWagon_FRAMEWORKS = UIKit</p>

<p>6.make, make package, make install</p>

<h1>参考资料</h1>

<p>1.<a href="http://wufawei.com/2013/08/iOS-jailbroken-programming-1/">http://wufawei.com/2013/08/iOS-jailbroken-programming-1/</a></p>

<hr />

<h1>越狱开发精彩回答</h1>

<p>最近笔者研究越狱开发,现总结了一些资料知乎上他人对越狱开发学习流程的精彩回答.</p>

<p>1.suu，iOS Researcher</p>

<pre>
①去Cydia下载Theos Tutorials，并在谷歌上了解theos相关信息。
②Mac上安装iOSOpenDev，并了解相关信息。
入门教程最多Hello World，剩下的去Github上找源码吧，比如killbackgrounds

我也上传了一个:
http://github.com/al1enSuu/Slide2Dismiss
</pre>


<p>2.季逸超，Peak-Labs创始人/CEO,猛犸浏览器、Rasgue…</p>

<pre>
有幸被邀请回答，不过不知道您要了解的'系统机制'有多深入? ;-)
按照意图和深度的话，大概有这么几种途径与资源：

1.为了学习框架，提升开发水平，可以看看私有API列表。iOS (Cocoa Touch)的各私有API都可以通过runtime查看获得，您可以自己写个method browser。如果觉得麻烦的话可以到Github看现成的，我收藏了俩: https://github.com/kennytm/iphone-private-frameworks 和 https://github.com/nst/iOS-Runtime-Headers ，但还是推荐自己来实时获取，因为iOS在更新，API也在更新。在App Store产品中使用私有API是违反苹果规定的，所以能不用这些API而实现一些功能是iOS工程师水平的体现。

2.对iOS工程师而言，如果只是开发的话(1)也就差不多了。如果您十分有爱，想了解API以下的东西的话，依然可以利用Obj-C的runtime。可以在这里看到 http://opensource.apple.com/source/objc4/objc4-493.11/runtime/ ，尤其是objc-runtime.m，这里提供了很多学习用的"工具"。比如经典的method_exchangeImplementations()，您可以用它研究很多黑箱过程的来龙去脉。值得一提的是，这种技巧(method swizzling)是合法的,可以在App Store 中使用! 苹果曾给使用了相关技巧的开发者发过邮件，表示出于安全性和稳定性最好不再使用，但没有禁止。

3.如果是对系统本身感兴趣的话，不妨越狱看看。iOS和Mac OS X类似，基于Darwin，是一种UNIX系统。越狱后你就有了root权，可以安装个Terminal，装gcc都没问题的哈哈~ 接下来就像您研究Linux那样摆弄就好了。对于开发者来说，有了root权也就可以写一些system tweak或全局的代码，自然也可以用来深入了解系统、原生app等。这方面我很久没折腾了，所以不敢瞎说。

4.如果您是想成为一名iOS Hacker的话，最近有本书挺火的: http://www.amazon.com/iOS-Hackers-Handbook-Charlie-Miller/ 我没空看不知道咋样，但作者很神。另外现在iOS越狱界也有了自己的大会，可以看看“越狱梦之队”的演讲和文档: http://absinthejailbreak.com/dream-team-presentation-at-hitbsecconf-videos/ 。如果您还是没有满足的话，可以看看从硬件入手的逆向工程和调试，分享一个我收藏的宝贝: http://wenku.baidu.com/view/dae22c30eefdc8d376ee32c9.html

5.另外说iOS代码是封闭/闭源的其实不全对，苹果算是开源界的一面大旗了，比如WebKit。iOS的组成部分也一样是开源的，可以在官网 http://opensource.apple.com/ 看到，最新的iOS 5.1.1在这: http://opensource.apple.com/release/ios-511/ 。但是如您所见，这里并没有iOS操作系统的代码，而是一些库和编译器、调试器...其中JavaScriptCore和WebCore很有用，这两者是WebKit的基础，可以说WebKit是iOS最重要的组成之一，截止iOS 5 (6我还没下呢=___=)，所有多于一行文字的控件其实都是WebKit标准的(不可思议吧?!)。很多iOS的Hack都是从这里开始的。说到WebKit,之前Comex大神的Spirit越狱(那个"Slide to Jailbreak")就是利用Safari->WebKit->PDF Engine->TIFF字体的漏洞实现了代码注入！所以每一个系统组件都可能是iOS逆向/Hack的突破口！
</pre>


<h1>参考资料:</h1>

<p>1.<a href="http://www.zhihu.com/question/20954912">http://www.zhihu.com/question/20954912</a>
2.<a href="http://www.zhihu.com/question/20317296/answer/14735312">http://www.zhihu.com/question/20317296/answer/14735312</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[git常用命令]]></title>
    <link href="http://MonaDogg.github.io/blog/2013/12/03/gitchang-yong-ming-ling/"/>
    <updated>2013-12-03T11:12:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2013/12/03/gitchang-yong-ming-ling</id>
    <content type="html"><![CDATA[<p>如果读者想成git高手,本文也许并不适合你,我在这里推荐一本书为&lt;Git权威指南>,这本书会介绍git的方方面面,如果读者是一位并不清楚git基础知识的读者,那么建议读者先从<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">这里</a>开始学习git.本文主要记载日常使用git中常用的命令,并尽量讲清楚使用该命令的使用场景.</p>

<h1>1.本地操作</h1>

<h2>1.1初始化</h2>

<h3>1.1.1全局变量</h3>

<pre>
git config --global user.name "xxx"

git config --global user.email "xxx@qq.com"

git config --global color.ui "always"
</pre>


<h3>1.1.2初始化新版本库</h3>

<pre>
git init 只会在根目录下建立一个名为.git文件夹
</pre>


<h3>1.1.3设置忽略的文件</h3>

<p>1.设置每个人都需要忽略的文件</p>

<p>1)在根目录新建一个名为.gitignore的文本文件</p>

<p>2)在命令行执行echo *.jpg>.gitignore,注意>左右不要有空格</p>

<p>3)将.gitignore文件加入版本库并提交</p>

<p>2.设置只有自己忽略的文件</p>

<p>1)修改.git/info/exclude文件</p>

<p>2)可以使用正则表达式,例如<em>.[oa]等价于</em>.o和*.a</p>

<h3>1.1.4添加文件到版本库</h3>

<p>1.添加单个文件</p>

<pre>
git add somefile.tet
</pre>


<p>2.添加所有txt文件</p>

<pre>
git add *.txt
</pre>


<p>3.添加所有文件</p>

<pre>
git add . 包含子目录但是不包含空目录
</pre>


<h3>1.1.5提交</h3>

<p>1.提交</p>

<p>git commit -m &ldquo;add all files&rdquo;</p>

<h2>1.2日常操作</h2>

<h3>1.2.1提交</h3>

<p>1.提交所有修改</p>

<pre>
git commit -m "some message" -a
</pre>


<p>2.提交单个文件</p>

<pre>
git commit -m "some message" readMe.txt
</pre>


<p>3.增补提交</p>

<pre>
git commit -C head -a -amend 
</pre>


<p>不会产生新的提交历史记录</p>

<h3>1.2.2撤销修改</h3>

<p>1.撤销尚未提交的修改</p>

<p>1)撤销少量文件</p>

<pre>
git checkout head readMe.txt toDo.txt
</pre>


<p>2)撤销所有txt文件</p>

<pre>
git checkout head *.txt
</pre>


<p>3)撤销所有文件</p>

<pre>
git checkout head
</pre>


<p>2.撤销提交后的修改</p>

<p>1)撤销某次提交,但是这次操作也会作为一次提交保存</p>

<pre>
git revert -no-commit head
</pre>


<p>2)复位,将当前head内容重置,会留下痕迹</p>

<pre>
git reset head/git reset head <filename>
</pre>


<p>3)复位到head之前的版本,不会在版本库留下痕迹</p>

<pre>
git reset --hard head^
</pre>


<p>4)永久删除最后3个commit(即HEAD, HEAD^和HEAD~2)</p>

<pre>
git reset --hard head~3
</pre>


<h3>1.2.3分支</h3>

<p>1)列出本地分支</p>

<pre>
git branch
</pre>


<p>2)列出所有分支</p>

<pre>
git branch -a
</pre>


<p>3)基于当前分支末梢创建新分支</p>

<pre>
git branch <branchname>
</pre>


<p>4)检出分支</p>

<pre>
git checkout <branchname>
</pre>


<p>5)基于当前分支的末梢创建新分支并检出分支</p>

<pre>
git checkout -b <branchname>
</pre>


<p>6)基于某次提交/分支/标签 创建新分支</p>

<pre>
git branch emputy bfe57de0      //用来查看某个历史断面很方便

git branch emputy2 emputy       //基于分支创建分支
</pre>


<p>7)合并分支</p>

<p>1.普通合并:把两条分支以上的历史轨迹合并，交汇到一起
合并并提交,如果发生冲突就不会自动提交,如果冲突很多,不想立即解决他们,
可以直接使用git checkout head撤销所有尚未提交的修改.</p>

<pre>
git merage <branchname>
</pre>


<p>合并但并不提交</p>

<pre>
git merage --no--commit
</pre>


<p>2.压合合并:将一条分支上的若干个提交条目合成一个提交条目，提交到另一个分支末梢。</p>

<p>压合合并并提交</p>

<pre>
git merge --squash <branchname>
</pre>


<p>压合合并并不提交</p>

<pre>
git merge --squash --no-commit <branchname>
</pre>


<p>3.拣选合并:拣选另一条分支上的某个提交条目的改动带到当前分支上。
挑选某次提交合并但不提交</p>

<pre>
git cherry-pick --no-commit 5b62b6
</pre>


<p>8)重命名分支</p>

<pre>
git branch -m <branchname><newname> 不会覆盖已存在同名分支

git branch -M <branchname><newname> 会覆盖已存在的同名分支
</pre>


<p>9)删除分支</p>

<pre>
git branch -d new2  如果分支没有被合并会删除失败

git branch -D new2  如果分支没有被合并也会被删除
</pre>


<h3>1.2.4解决冲突</h3>

<p>1)冲突很少时,直接编辑冲突文件提交即可</p>

<h3>1.2.5标签</h3>

<p>1)创建标签</p>

<p>1.为当前分支最近一次提交创建标签</p>

<pre>
git tag 1.0 //标签无法重新命名
</pre>


<p>2.为其他分支最近一次提交创建标签</p>

<pre>
git tag tagName branchName
</pre>


<p>3.为某次历史提交创建标签
git tag 1.1 4e6861d5
2)显示标签列表</p>

<pre>
git tag
</pre>


<p>3)检出标签</p>

<pre>
git checkout 1.0    //查看标签断面很重要,但是不能提交
</pre>


<p>4)由标签创建分支</p>

<pre>
git branch b1.1 1.1
git checkout -b b1.1 1.1
</pre>


<p>5)删除标签</p>

<pre>
git tag -d 1.1
</pre>


<h3>1.2.6查看状态</h3>

<p>1)当前状态</p>

<pre>
git status
</pre>


<p>2)历史记录</p>

<pre>
git log

gitk    //查看当前分支的历史记录

gitk <branchname>    //查看某分支历史记录

gitk --all  //查看所有分支

git branch -v   //每个分之最后的提交
</pre>


<h3>1.2.7其他</h3>

<p>1)git导出项目,更多用法请参照git help archive</p>

<pre>
git archive [options] <tree-ish> [<path>…]

git archive --format zip -o filename.zip HEAD

git archive --format zip -o filename.zip source
</pre>


<p>一其中tree-ish可以是:</p>

<pre>
HEAD
Tags
Branch names
Branch names with remotes, like origin/somebranch
</pre>


<h1>2.远程操作</h1>

<h2>2.1初始化</h2>

<p>1)克隆版本库</p>

<pre>
git clone <url>
</pre>


<p>2)别名</p>

<pre>
git remote add <别名> <远程版本库的URL>   //添加远程版本库的别名

git remote rm <别名>       //删除远程库的别名和相关分支
</pre>


<h2>2.2日常操作</h2>

<p>1)分支</p>

<pre>
git branch -r   //列出远程分支

git remote prune origin     //删除远程库中已经不存在的分支
</pre>


<p>2)从远程获取</p>

<p>1.获取远程版本库但是并不合并</p>

<pre>
git fetch <远程版本库>  //获取但不合并

git fetch origin    //origin是远程库的别名

git fetch d:\git\source     //本地版本库
</pre>


<p>2.获取远程版本库并且和当前分支合并</p>

<pre>
git pull origin 

git pull d:\git\source master
</pre>


<p>3)推入远程库</p>

<pre>
git push origin master  //推入远程库
</pre>


<h1>参考文献:</h1>

<p>1.本文内容来自:weibo.com/crespoxiao的微博配图</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[又是一个github博客]]></title>
    <link href="http://MonaDogg.github.io/blog/2013/12/03/you-shi-yi-ge-githubbo-ke/"/>
    <updated>2013-12-03T11:10:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2013/12/03/you-shi-yi-ge-githubbo-ke</id>
    <content type="html"><![CDATA[<p>在github上拥有一个博客地址,本人觉得是一件挺酷的事情,于是乎翻遍了网上大部分的教程,在花费了一天半的时间后,终于搭建完成了,其中遇到了很多的坑,幸亏在时间的软磨硬泡下,一一被我解决了(主要是对ruby环境的不熟悉造成的).</p>

<h1>1.搭建ruby环境</h1>

<p>搭建rvm环境和相关的设置</p>

<p>rvm是一个命令行工具，可以提供一个便捷的多版本ruby环境的管理和切换,下面的代码是用来安装rvm的.</p>

<pre>
bash -s stable < <(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer)
</pre>


<p>然后需要设置环境变量:</p>

<pre>
echo '[[ -s "$HOME/.rvm/scripts/rvm" ]] && . "$HOME/.rvm/scripts/rvm" # Load RVM function' >> ~/.bash_profile
source ~/.bash_profile

# If using Zsh do this instead
echo '[[ -s $HOME/.rvm/scripts/rvm ]] && source $HOME/.rvm/scripts/rvm' >> ~/.zshrc
source ~/.zshrc
</pre>


<p>最终需要安装ruby环境(不知道为何安装1.9.2会报奇怪的错,换成1.9.3就好了):</p>

<pre>
rvm install 1.9.3 && rvm use 1.9.3
rvm rubygems latest
</pre>


<h1>2.安装Octopress</h1>

<p>克隆代码到当前目录下,并且进入octopress目录:</p>

<pre>
git clone git://github.com/imathis/octopress.git octopress
cd octopress
</pre>


<p>安装相关的依赖库:</p>

<pre>
gem install bundler
bundle install
</pre>


<p>最后安装Octopress</p>

<pre>
rake install
</pre>


<h1>3.简单设置你的博客</h1>

<p>1)修改文件_config.yml,里面基本上是一些博客名称,作者姓名等等之类的设置信息.</p>

<p>2)修改source文件夹下一些html中twitter,google等政府屏蔽网站的相关资源,会造成页面加载缓慢,具体判断建议使用chrome,查看每项资源的加载时间,将无法获取的资源保存到本地,或者换为墙内的加载地址.</p>

<h1>4.设置github账号</h1>

<p>在github上创建一个名为 账号名.github.com 的代码仓库。</p>

<h1>5.写博客</h1>

<p>写博客的主要命令为：</p>

<pre>
rake new_post[‘article name’] 生成博文框架，然后修改生成的文件即可
rake generate 生成静态文件
rake preview 在http://localhost:4000 访问博文内容
rake deploy 将生成的博文推送到你的github上
同时我也建议把所有的源码也推送到github进行保存,代码一般为:
git add .
git commit -m "add source files"
git push origin source
</pre>


<h1>6.关于markdown</h1>

<p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”</p>

<p>我们在github上面存放的博客其实是通过ruby下的一个框架,将我们使用markdown语法编写的博文 转换为html网页.在这里赞赏下网友们的智慧.</p>

<p>而markdown的教程网上有很多,你可以先点击<a href="http://zh.wikipedia.org/wiki/Markdown">这里</a>进行了解.</p>

<h1>7.美化我们的博客</h1>

<p>如果你觉得我们安装好的博客挺丑的,而且评论功能也很难用,还有那个定制栏能不能放点别的什么,那我们就需要动手改造了,在这里我仅仅介绍下安装主题的方法.</p>

<p>我使用的主题是<a href="https://github.com/gehaxelt/CSS-WhiteLake">whitelake</a>:</p>

<pre>
cd octopress
git clone https://github.com/gehaxelt/CSS-WhiteLake.git .themes/whitelake
rake install['whitelake']
rake generate
rake preview
</pre>


<p>别的模块定制方法也许你应该看看<a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">这个</a>.</p>

<h1>参考文献:</h1>

<p>1.首先感谢唐巧的博客,本文的大部分内容都是来自他的一篇<a href="http://blog.devtang.com/blog/2012/02/10/setup-blog-based-on-github/">博文</a>,作为iOS工程师我也建议你关注他们的微博,并且仔细研读他的每篇博文,真是收获颇丰.</p>

<p>2.<a href="http://ishalou.com/blog/2012/10/15/how-to-use-octopress/">http://ishalou.com/blog/2012/10/15/how-to-use-octopress/</a></p>

<p>3.<a href="http://hahaya.github.io/2013/06/26/build-blog-on-github.html">http://hahaya.github.io/2013/06/26/build-blog-on-github.html</a></p>

<p>4.<a href="http://www.cnblogs.com/rubylouvre/archive/2012/06/10/2543706.html">http://www.cnblogs.com/rubylouvre/archive/2012/06/10/2543706.html</a></p>

<p>5.<a href="http://easypi.github.io/blog/2013/01/05/using-octopress-to-setup-blog-on-github/">http://easypi.github.io/blog/2013/01/05/using-octopress-to-setup-blog-on-github/</a></p>

<p>以下是美化博客:</p>

<p>6.<a href="http://yanping.me/cn/blog/2012/01/07/theming-and-customization/">http://yanping.me/cn/blog/2012/01/07/theming-and-customization/</a></p>

<p>7.<a href="http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/">http://biaobiaoqi.me/blog/2013/07/10/decorate-octopress/</a></p>

<p>8.<a href="http://xuhehuan.com/886.html">http://xuhehuan.com/886.html</a></p>

<p>9.<a href="http://lucifr.com/2012/02/05/slash-theme-for-octopress/">http://lucifr.com/2012/02/05/slash-theme-for-octopress/</a></p>
]]></content>
  </entry>
  
</feed>
