<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | MonaDogg]]></title>
  <link href="http://MonaDogg.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://MonaDogg.github.io/"/>
  <updated>2014-03-07T06:17:40+08:00</updated>
  <id>http://MonaDogg.github.io/</id>
  <author>
    <name><![CDATA[MonaDogg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[《java并发编程实战》读书笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/03/07/java-multithreading/"/>
    <updated>2014-03-07T06:12:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/03/07/java-multithreading</id>
    <content type="html"><![CDATA[<h1>第一章.简介</h1>

<p>如果想要充分发挥多处理器系统的强大计算能力,最简单的方式就是使用线程.</p>

<p>在不同进程之间可以通过一些粗粒度的通信机制来交换数据,包括:套接字,信号处理器,共享内存,信号量以及文件等.</p>

<p>一种高效的运行方式是通过粗粒度的时间分片使这些用户和程序能共享计算机的资源.</p>

<p>线程会共享进程范围内的资源,例如内存句柄和文件句柄,但每个线程都有各自的程序计数器,栈以及局部变量等.</p>

<p>如果没有明确的协同机制,那么线程将彼此独立执行,由于同一个进程中的所有线程都将共享进程的内存地址空间,因此这些线程都能够访问相同的变量并在同一个堆上分配对象,这就需要
实现一种比在进程间共享数据粒度更细的数据共享机制,如果没有明确的同步机制来协同对共享数据的访问,那么当一个线程正在使用某个变量的时候,另一个线程可以同时访问这个变量
,这将造成不可预测的结果.</p>

<p>这就好比在等待水烧开的同时看报纸,而不是等到水烧开之后再开始看报纸.</p>

<p>线程安全性可能是非常复杂的,没有充足同步的情况下,多个线程中的执行顺序是不可预测的,甚至会产生奇怪的结果.</p>

<p>安全性问题:永远不发生糟糕的事情,不要顺序错误的执行.
活跃性问题:某件正确的事情最终会发生,当某个操作无法执行下去,就会产生活跃性问题,例如死锁.
性能问题:在多线程程序中,当线程调度器临时挂起活跃线程并转而运行另一个线程时,就会频繁的出现上下文切换操作,这种操作会带来极大的开销,当线程共享数据的时候,必须使用同步
机制,这些机制往往造成编译器优化,使的内存缓存区中的数据无效.</p>

<p>swing的一些组件并不是线程安全的,swing程序通过将所有对GUI组件的访问局限在事件线程中以实现线程的安全性,如果某个应用程序希望在事件线程之外控制GUI,那么必须
将控制GUI的代码放在事件线程中运行.</p>

<h1>第二章.线程安全性</h1>

<p>要编写线程安全的代码,其核心在于要对状态访问操作进行管理,特别是对共享的和可变的状态的访问.</p>

<p>从非正式的意义上来说,对象的状态是指存储在状态变量(例如实例或者静态域)中的数据,对象的状态可能包含其他依赖对象的域,例如HashMap.</p>

<p>&ldquo;共享"意味着变量可以由多个线程同时访问,而"可变"则意味着变量的值在其生命周期内可以发生变化.</p>

<p>一个对象是否需要是线程安全的,取决于它是否被多个线程访问,这指的是在程序中访问对象的方式,而不是对象要实现的功能,要使得对象是线程安全的,需要采用同步机制来协同可变状态的
访问.</p>

<p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作的时候,必须采用同步机制协同这些线程对变量的访问.(关键字:synchronized),但同步这个术语还包含volatile类型的
变量,显式锁(explicit lock)以及原子变量.</p>

<p>如果有多个线程访问同一个可变的状态变量的时,没有使用合适的同步,那么程序就会出现错误,有三种方法可以修复这种问题:</p>

<pre><code>1)不在线程之间共享该状态变量
2)将状态变量修改为不可变的变量
3)在访问状态变量的时候使用同步
</code></pre>

<p>在编写并发应用程序的时候,一种正确的编程方法是,首先让代码正确的运行,然后再提高代码的速度.</p>

<p>当多个线程访问某个类的时候,这个类始终都能保持为正确的行为,那么称这个类为线程安全的.</p>

<p>如果在线程安全类中封装了必要的同步机制,那么客户端无需进一步的采取同步措施.</p>

<p>无状态的对象一定是线程安全的,(例如servlet,既不包含任何域,也不包含任何对其它类中遇的引用).</p>

<p>原子性:原子操作是不可分割的，在执行完毕不会被任何其它任务或事件中断, 能够在单条指令中完成的操作都可以认为是" 原子操作".</p>

<p>&ldquo;读取-修改-写入"操作序列,其结果依赖于之前的状态.</p>

<p>竞态条件(race condition):在并发变编程中,这种由于不恰当的执行时序而出现不正确的结果,称为竞态条件.</p>

<p>最常见的竞态类型是"先检查后执行"操作,通过一个可能失效的观测结果来决定下一步的操作.例如:构建单例的时候,容易产生竞态条件.</p>

<p>另外一种竞态条件是"读取-修改-写入"这种操作.</p>

<p>要避免竞态条件问题,就必须在某个线程修改该变量的时,通过某种方式阻止其他线程使用这个变量,从而确保其他线程只能在修改操作完成之前或之后读取和修改状态,而不是在修改状态
过程中.</p>

<p>在实际情况中,应尽可能的使用现有的线程安全对象来管理类的状态,与非线程安全对象相比,判断线程安全的对象可能的状态及其状态转换情况要更加容易,从而更容易维护和验证线程
安全性.</p>

<p>要保持状态的一致性,就需要在单个原子操作中更新所有相关的状态变量.</p>

<p>内置锁:同步代码块(synchronized block),线程在进入同步代码块之前会自动获得锁,并且在退出代码块的时候,自动释放锁.从而让这一组语句作为一个不可分割的单元被执行.但是这种方法却过于极端
可能会造成效率低下.</p>

<p>重入:内置锁是可以重入的,某个线程获取一个他已有的锁,这个请求就会成功,重入的一种实现方法是,每个锁关联一个获取计数值和一个所有者线程,当计数值为0的时候,这个锁就会被
认为没有任何线程持有,当线程请求一个未被持有的锁时候,jvm记下锁的持有者,并且将获取的计数值为1,如果同一个线程获取就会递增,当线程退出代码快的时候,就会-1,当计数值
为0的时候,这个锁将被释放.</p>

<p>一种常见的加锁约定是,将所有的可变状态都封装在对象的内部,并通过对象的内置锁对所有访问可变状态的代码路径进行同步,使得该对象上不会发生并发访问.</p>

<p>同步代码快应该尽可能的缩小代码范围</p>

<p>当使用锁的时候,你应该清楚代码块中实现的功能,以及在执行该代码快时候是否需要很长的时间,无论是执行计算密集的操作,还是在执行某个可能阻塞的操作,如果持有锁的时间过长
那么就会带来活跃性或者性能的问题.</p>

<h1>第三章:对象的共享</h1>

<p>重排序:在没有同步的情况下,编译器,处理器以及运行时候都可能对操作执行的顺序,进行一些意想不到的调整,在缺乏足够同步的多线程程序中,要相对内存操作的执行顺序进行判断,几乎
无法得到正确的结论.</p>

<p>只要有数据在多个线程之间共享,就使用正确的同步.</p>

<p>为什么在访问同个共享且可变的变量时要求所有线程在同一个锁上同步,就是为了确保某个线程写入该变量的值,对于其他线程来说都是可见的,否则,如果一个线程在未持有正确锁的
情况下读取这个变量,那么读到的可能是一个失效值.</p>

<p>加锁的意义不仅仅局限于互斥行为,还包含内存的可见性,为了确保所有线程都能看到共享变量的最新值,所有执行读操作或者写操作的线程都必须在同一个锁上同步.</p>

<p>volatile变量,用来确保将变量的更新操作通知到其他线程,读取volatile变量的时候总是会返回最新写入的值,因此volatile变量是一种比sychronized关键字更轻量级的同步机制.
仅当volatile变量能够简化代码实现以及对同步策略的验证时,才应该使用它们,应该确保它们自身的状态可见性,和他们引用的状态可见性,以及标识一些重要的程序生命周期
事件的发生,例如:</p>

<pre><code>    volatile boolean asleep;
    ....
        while(!asleep)
            countSomeSheep();
</code></pre>

<p>加锁机制可以保证可见性和原子性,而volatile仅能够保证可见性.</p>

<p>当且仅当满足以下所有条件时,才应该使用volatile变量:
当变量的写入操作不依赖变量的当前值,或者你确保只有单个线程更新变量的值.
该变量不会与其他状态变量一起纳入不变性条件中.
在访问变量时不需要加锁.</p>

<p>当某个对象封闭在一个线程中的时候,这种用法将自动实现线程安全性,即使被封闭的对象本身不是线程安全的.</p>

<p>在volatile变量上存在一种特殊的线程封闭,只要你能确保只有单个线程对共享的volatile变量执行写入操作,那么就可以安全地在这些共享的volatile变量上执行"读取-修改-写入"的操作,在这种情况下,
相当于将修改操作封闭在单个线程中以防止发生竞态条件,并且volatile变量的可见性保证还确保了其他线程可以看到最新的值.</p>

<p>不可变对象一定是线程安全的.</p>

<p>当满足下面的条件时候,对象才是不可变的:</p>

<pre><code>对象创建之后,其状态就不可以修改了.
对象的所有域都是final类型.
对象是正确创建的(建议使用工厂方法构建对象,具体来说只有析构函数返回时,this引用才应该从线程公开,析构函数可以将this指针保存到某个地方,只要其他线程不会再构造函数完成之前使用它.
</code></pre>

<p>如何线程都可以在不需要额外同步的情况下安全的访问不可变对象,即使在发布这些对象时没有使用同步.</p>

<p>可变对象必须通过安全的方式来发布,这通常意味着在发布和使用该对象的线程时都必须使用同步.</p>

<pre><code>要安全地发布一个对象,对象的引用以及对象的状态必须同时最其他线程可见,一个正确的构造的对象可以通过以下方式来安全的发布:

在静态初始化函数中初始化一个对象的引用,
将对象的引用保存在volatile类型,或者是AtomicReferance对象中,
将对象的引用保存到某个正确构造对象的final类型域中,
将对象的引用保存到一个由锁保护的域中.
</code></pre>

<p>对于可变对象,不仅在发布对象的时候需要使用同步,并且在每次对象访问的时候,同样需要使用同步来确保后续操作的可见性
对象的发布需求取决于他的可变性:</p>

<pre><code>不可变对象可以通过任意机制来发布
事实不可变对象必须通过安全的方式来发布
可变对象必须通过安全的方式来发布,并且必须是线程安全的或者由某个锁保护起来.
</code></pre>

<p>在并发程序中使用和共享某个对象的时,可以使用一些实用的策略,包括:</p>

<pre><code>线程封闭:线程封闭的对象只能有一个线程拥有,对象被封闭在该线程中,并且只有这个线程修改.
只读共享:在没有额外同步的情况下,共享的只读对象可以由多个对象并发访问,但任何线程都不能修改它,共享的只读对象包括不可变对象,和事实不可变对象.
线程安全共享:线程安全的对象在其内部实现同步,因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步.
保护对象:被保护的对象只能通过持有特定的锁来访问,保护对象包括封装在其他线程安全对象中的对象,以及已发布的并且由某个特定锁保护的对象.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[(一)链表笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/02/23/linklistnote/"/>
    <updated>2014-02-23T22:26:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/02/23/linklistnote</id>
    <content type="html"><![CDATA[<p>最近发现自己数据结构和算法十分薄弱,于是准备复习这方面的知识,选用的教材是&lt;算法精解-c语言描述>,在此,把复习中的笔记记录如下.</p>

<p>其中涉及的知识点:</p>

<h2>1.格式化输出函数fprintf()中的stdout、stderr</h2>

<p>printf将格式化写到标准输出，fprintf写至指定的流。</p>

<p>stdin:标准输入
stdout:标准输出
stderr:标准错误</p>

<p>int fprintf(
   FILE <em>stream,                    //为 FILE 结构的指针
   const char </em>format [,
   argument ]&hellip;
);</p>

<h2>2.宏定义的写法</h2>

<p>宏定义默认都大写,不需要类型,没有{}只有()</p>

<pre>
//得到链表中的尾元素
#define list_tail(list) ((list)->tail)

//判断该元素是不是头元素
#define list_is_head(list, element) ((element) == ((list)->head) ? 1 : 0)
</pre>


<h2>3.c语言常用库</h2>

<pre><code>#include &lt;stdlib.h&gt;
//stdlib 头文件即standard library标准库头文件
//本例中用了内存申请和释放:malloc()和free()

#include &lt;string.h&gt;
//C语言里面关于字符数组的函数定义的头文件
//本例中用了memset()重置内存区域
</code></pre>

<h2>4.memset的用法</h2>

<pre><code>//设置缓冲区到制定的位置
void *memset(
   void *dest,      //开始的内存地址
   int c,               //设置值
   size_t count     //设置的长度
);
memset(tempList, 0, sizeof(NewList));
</code></pre>

<p>设置tempList开始的内存地址,长度为NewList类型的长度,值为0</p>

<h2>5.如何申请内存和释放内存</h2>

<p>1)申请内存</p>

<pre><code>if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL)
      return -1;
</code></pre>

<p>2)释放内存</p>

<pre><code>free(willDeleteListElement);
</code></pre>

<h2>6.以下为链表的实现文件</h2>

<p>linkList.h</p>

<pre><code>//
//  linkList.h
//  clist
//
//  Created by lee on 14-2-23.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#ifndef clist_linkList_h
#define clist_linkList_h

//定义链表元素结构
typedef struct LinkListElement_
{
    void *data;
    struct LinkListElement_ *nextElement;
}LinkListElement;

//定义链表结构
typedef struct LinkList_
{
    LinkListElement *headListElement;
    LinkListElement *tailListElement;
    int size;
    //如果data是自定义类型,那么需要初始化的时候设置destroy来释放内存
    void (*destroy)(void *data);
}LinkList;


//初始化链表
void linkListInit(LinkList *linkList,void (* destroy)(void *data));

//删除,返回0为正常,其他为异常
int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data);

//插入
int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data);
//int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,const void *data);

//销毁
void linkListDestroy(LinkList *linkList);

#define LINKLIST_SIZE(linkList) (linkList-&gt;size)
#define LINKLIST_HEAD_ELEMENT(linkList) (linkList-&gt;headListElement)
#define LINKLIST_TAIL_ELEMENT(linkList) (linkList-&gt;tailListElement)
#define LINKLIST_DATA(linklistElement) (linklistElement-&gt;data)
#define LINKLIST_NEXT(linklistElement) (linklistElement-&gt;nextElement)
#define LINKLIST_IS_HEAD_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_HEAD_ELEMENT(linkList) ? 1 : 0 )
#define LINKLIST_IS_TAIL_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_TAIL_ELEMENT(linkList) ? 1 : 0 )

#endif
</code></pre>

<p>linkList.m</p>

<pre><code>//
//  linkList.c
//  clist
//
//  Created by lee on 14-2-25.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "linkList.h"


void linkListInit(LinkList *linkList,void (* destroy)(void *data))
{
    linkList-&gt;headListElement = NULL;
    linkList-&gt;tailListElement = NULL;
    linkList-&gt;size = 0;
    linkList-&gt;destroy = destroy;
    return;
}


//考虑是否从头删除,并且考虑链表新的头尾元素
//非从头删除,需要考虑新的尾元素

int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data)
{


    if (LINKLIST_SIZE(linkList) == 0 || frontListElement == LINKLIST_TAIL_ELEMENT(linkList)) {
        return -1;
    }

    LinkListElement *deleteElement;

#pragma -mark 没有考虑frontListElement = NULL的情况
//    LinkListElement *deleteElement = frontListElement-&gt;nextElement;
//    *data = deleteElement-&gt;data;

    if (frontListElement == NULL) {

        deleteElement = LINKLIST_HEAD_ELEMENT(linkList);
        *data = deleteElement-&gt;data;

        //包含为NULL的情况
        linkList-&gt;headListElement = deleteElement-&gt;nextElement;
        if (LINKLIST_HEAD_ELEMENT(linkList) -&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = LINKLIST_HEAD_ELEMENT(linkList);
        }

    }else{

        deleteElement = frontListElement-&gt;nextElement;
        *data = deleteElement-&gt;data;

        frontListElement-&gt;nextElement = deleteElement-&gt;nextElement;
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = frontListElement;
        }
    }

    free(deleteElement);
    linkList-&gt;size --;
    return 0;
}





//从头插入,判断当前列表是否有元素,进而判断链表的头尾元素
//非从头插入,需要考虑是否插入元素是否为尾元素

int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data)
{
    LinkListElement *insertElement;
    if((insertElement = (LinkListElement *)malloc(sizeof(LinkListElement))) == NULL)
        return -1;
    insertElement-&gt;data = data;

    if (frontListElement == NULL) {
        //如果没有元素,或者没有元素
        if (LINKLIST_SIZE(linkList) == 0) {
            linkList-&gt;tailListElement = insertElement;
        }else{
            insertElement-&gt;nextElement = linkList-&gt;headListElement;
        }
        linkList-&gt;headListElement = insertElement;


    }else{
#pragma -mark 当插入元素是尾元素的情况
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = insertElement;
        }

        insertElement-&gt;nextElement =  frontListElement-&gt;nextElement;
        frontListElement-&gt;nextElement = insertElement;
    }

    linkList-&gt;size ++;

    return 0;
}






//需要遍历释放list中的各个元素的data,并且需要判断destroy是否存在

void linkListDestroy(LinkList *linkList)
{
    void *data = NULL;

    while (LINKLIST_SIZE(linkList) &gt; 0) {

#pragma -mark 不要忘记destroy为NULL的情况
        if(linkListDelete(linkList, NULL, (void **)data) == 0 &amp;&amp; linkList-&gt;destroy != NULL ){
            linkList-&gt;destroy(data);
        }
    }

    memset(linkList,0,sizeof(LinkList));
}
</code></pre>

<p>双向链表:与链表的差距仅仅是多了一个前驱指针,在代码上的差别是,仅仅允许在链表为空的时候,才能从链表的头部插入指针.
dlist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef DLIST_H
#define DLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked list elements.                       *
*                                                                            *
*****************************************************************************/

typedef struct DListElmt_ {

void               *data;
struct DListElmt_  *prev;
struct DListElmt_  *next;

} DListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked lists.                               *
*                                                                            *
*****************************************************************************/

typedef struct DList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

DListElmt          *head;
DListElmt          *tail;

} DList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data));

void dlist_destroy(DList *list);

int dlist_ins_next(DList *list, DListElmt *element, const void *data);

int dlist_ins_prev(DList *list, DListElmt *element, const void *data);

int dlist_remove(DList *list, DListElmt *element, void **data);

#define dlist_size(list) ((list)-&gt;size)

#define dlist_head(list) ((list)-&gt;head)

#define dlist_tail(list) ((list)-&gt;tail)

#define dlist_is_head(element) ((element)-&gt;prev == NULL ? 1 : 0)

#define dlist_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)

#define dlist_data(element) ((element)-&gt;data)

#define dlist_next(element) ((element)-&gt;next)

#define dlist_prev(element) ((element)-&gt;prev)

#endif
</code></pre>

<p>dlist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "dlist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ dlist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;
list-&gt;tail = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_destroy(DList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (dlist_size(list) &gt; 0) {

   if (dlist_remove(list, dlist_tail(list), (void **)&amp;data) == 0 &amp;&amp; list-&gt;
      destroy != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(DList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_ins_next(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/


   //    当链表为空的时候,从头部插入元素

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   new_element-&gt;prev = element;

//判断尾元素
   if (element-&gt;next == NULL)
      list-&gt;tail = new_element;
   else
   //判断下一个元素的上元素
      element-&gt;next-&gt;prev = new_element;

   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_prev ----------------------------  *
*                                                                            *
*****************************************************************************/


int dlist_ins_prev(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/
//  只有链表没有元素的时候,才可以从头部插入


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage to be managed by the abstract data type.                 *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }


else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element; 
   new_element-&gt;prev = element-&gt;prev;

   if (element-&gt;prev == NULL)
      list-&gt;head = new_element;
   else
      element-&gt;prev-&gt;next = new_element;

   element-&gt;prev = new_element;

}


/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the new element.               *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- dlist_remove -----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_remove(DList *list, DListElmt *element, void **data) {

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element or removal from an empty list.                *
*                                                                            *
*****************************************************************************/

if (element == NULL || dlist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;data;

if (element == list-&gt;head) {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from the head of the list.                              *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = element-&gt;next;

   if (list-&gt;head == NULL)
      list-&gt;tail = NULL;
   else
      element-&gt;next-&gt;prev = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from other than the head of the list.                   *
   *                                                                         *
   **************************************************************************/

   element-&gt;prev-&gt;next = element-&gt;next;

   if (element-&gt;next == NULL)
      list-&gt;tail = element-&gt;prev;
   else
      element-&gt;next-&gt;prev = element-&gt;prev;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>

<p>循环链表:与链表的差距是没有尾指针,当链表中只有一个元素的时候,该元素的next指向自己.因为没有尾指针,所以实现起来也简单了不少.
clist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef CLIST_H
#define CLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular list elements.                            *
*                                                                            *
*****************************************************************************/

typedef struct CListElmt_ {

void               *data;
struct CListElmt_  *next;

} CListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular lists.                                    *
*                                                                            *
*****************************************************************************/

typedef struct CList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

//仅仅有头指针,没有尾巴指针
CListElmt          *head;

} CList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data));

void clist_destroy(CList *list);

int clist_ins_next(CList *list, CListElmt *element, const void *data);

int clist_rem_next(CList *list, CListElmt *element, void **data);

#define clist_size(list) ((list)-&gt;size)

#define clist_head(list) ((list)-&gt;head)

#define clist_data(element) ((element)-&gt;data)

#define clist_next(element) ((element)-&gt;next)

#endif
</code></pre>

<p>clist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "clist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ clist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void clist_destroy(CList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (clist_size(list) &gt; 0) {

   if (clist_rem_next(list, list-&gt;head, (void **)&amp;data) == 0 &amp;&amp; list-&gt;destroy
      != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(CList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_ins_next(CList *list, CListElmt *element, const void *data) {

CListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (CListElmt *)malloc(sizeof(CListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the element into the list.                                         *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (clist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = new_element;
   list-&gt;head = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_rem_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_rem_next(CList *list, CListElmt *element, void **data) {

CListElmt          *old_element;

/*****************************************************************************
*                                                                            *
*  Do not allow removal from an empty list.                                  *
*                                                                            *
*****************************************************************************/

if (clist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;next-&gt;data;

if (element-&gt;next == element) {

   /**************************************************************************
   *                                                                         *
   *  Handle removing the last element.                                      *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   list-&gt;head = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removing other than the last element.                           *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   element-&gt;next = element-&gt;next-&gt;next;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(old_element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7人机交互指南笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji/"/>
    <updated>2014-02-19T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji</id>
    <content type="html"><![CDATA[<p>p10:
iOS 7 具体体现了以下主旨:
· 依从(Deference)。用户界面(UI)应当有助于用户理解内容并与之互动,而非对抗。
· 清晰(Clarity)。文字在每种字号下都易于阅读,图标表意准确清晰,装饰也恰到其度,并以对功能的无比关 注驱动设计。
· 纵深(Depth)。视觉上的分层界面和逼真的动作使其更赋活力,提升了用户的愉悦和理解。</p>

<p>p17:
拥抱无边框按钮。在 iOS 7中,所有的条栏按钮都没有边框。
如果合适,还可以通过显示纤细的边框或者浅 色背景来让按钮更加突出。</p>

<p>p26:
避免要求用户提供设置信息,代之以:
·关注 80% 用户的需求。这样,大部分用户不需要进行任何设置,因为你的 app 已经按他们期望的方式设置好了。如果有一些功能只有极少数用户可能需要或者大部分用户只会用一次,请抛弃这样的功能。
·尽可能通过其他方式获取信息。如果你可以使用任何内置程序或设备中用户所提供的信息,那就从系统中获取 这些信息,而不要让用户再输一次。
·如果你确实需要提供设置信息,请让人们在你的 app 中输入。然后,尽快存储这些信息(例如,在你 app 的 设置中)。这样一来,在有可能体验到你 app 的乐趣前人们不会被迫切换到 iOS 的「设置」中了。如果人们 将来需要修改这些信息,可以在任何时间前往 app 的设置页面进行修改。
尽可能将登录延后。最好在用户没有登录时就可以通过导航来浏览你的 app 并使用部分功能。用户在在可以做点有 用的事情前通常已经从那些强制他们登录的 app 中离开了。
一般来说,以设备的默认方向启动。在 iPhone 上,其默认方向是竖屏;在 iPad 上,则是设备当前的方向。如果你 的 app 只支持横屏,你应该始终以横屏方式启动,然后让用户在需要时旋转设备。
注意:对于只支持横屏的 app,最好能同时支持横屏竖屏两种状态,即 Home 键会在左侧或右侧的状态。如果设备 已经处于横屏,除非有很好的理由支持,否则只支持横屏的 app 应当就以此方向启动。另外,对只支持横屏的 app,Home 键应该在其右侧。(如需了解更多关于支持不同设备方向的信息,请参阅「响应设备方向的改变」(第 56页))
显示一个和 app 首屏极其相似的启动画面。iOS 会在你的 app 启动的瞬间显示这个启动画面,这可以让用户感觉你 的 app 非常快,并让你有足够的时间去加载内容。参阅「启动画面」(第 180 页)了解如何创建启动画面。
如果可能,避免在用户首次加载你的 app 时让他们阅读免责声明或确认终端用户许可协议。你可以让 App Store 显 示你的免责声明或者终端用户许可协议(EULA),以便人们可以在下载 app 前读到它们。如果你确实需要在 app 内展示这些东西,请确保以一种和 UI 保持和谐的方式将其整合进去,并在商业需求和用户体验间把握平衡。
App 重启后要恢复其状态,以便用户可以从中断的地方继续使用,而不要让用户去记住如何返回之前所在的位置。如 需了解更多关于高效重建和恢复 app 状态的方式,请参阅「State Preservation and Restoration」。</p>

<p>随时准备停止
iOS 应用永远不会显示一个「关闭」或「退出」选项。人们退出一个 app 的方式就是切换到另一个 app、返回主屏 幕或者让设备进入睡眠模式。
当人们从你的 app 切换离开,iOS 的多任务处理会将其挂到后台,并切换到新 app 的界面中。为了应对这种情况, 你应当:
·尽快并尽可能频繁地在合理范围内存储用户数据。这样做是因为处于后台的 app 随时都有可能被退出或结束。</p>

<p>启动和停止
随时准备停止,当 app 停止时,尽可能最多地保存当前状态的细节。这样的话,当人们切换回来时就不会失去之前所处的情 境。例如,如果你的 app 有显示可滚动的数据,那在停止时要保存当前所处的滚动位置。你可以前往「State Preservation and Restoration」了解更多关于高效重建和恢复 app 状态的方式。
有些 app 可能需要在用户运行其他 app 时一直在后台运行。例如,当用户在另一款 app 中检查待办事项或者玩游 戏时,他们会希望让正在播放音乐的 app 能继续播放。想要了解如何正确优雅地处理多任务,请参阅「多任务处 理」(第 84 页)。
永远不要以程序化的方式自动退出一个 iOS app。用户有可能会将其认为是程序崩溃了。如果由于一些可预知的问 题导致程序无法使用,那你需要告诉用户发生了什么、他们能做点什么。</p>

<p>p29:
给每个交互元素以足够的间距,以便用户对内容和控件进行操作。可点击控件的点击区域不小于 44 x 44 点。</p>

<p>p30:
将重要内容和功能放到更重要的位置,以便用户可以更容易地关注主要任务。一些可行的方法是,将主要元素放置在 屏幕的上半部分,并靠近屏幕左侧(基于从左至右的阅读习惯).</p>

<p>利用视觉上的权重和平衡来向用户显示界面元素之间的相对重要程度。相比尺寸较小的元素,那些大尺寸的元素更吸 引目光,看上去也更重要。</p>

<p>随时准备应对文字大小的变化。当用户在「设置」中更改文字大小时,他们会希望大多数的 app 可以作出合适的响 应。为适应一些文字字号的变化,你可能需要调整布局;如需了解关于在 app 中显示文字的更多信息,请参阅「文 字清晰易读」(第 49 页)。</p>

<p>p34:
永远要让用户知道自己正处于应用中的什么位置,并清楚如何去往他的下一个目标。</p>

<p>用导航栏来让用户在层级数据之间轻松穿梭。</p>

<p>用标签栏来展示平级分类的内容或功能。</p>

<p>用页码控件来指示有多个子项目或多屏内容。(页码控件?)</p>

<p>总的来说,最好是给用户以唯一的路径前往每个页面。</p>

<p>p37
用户对标准手势了如指掌</p>

<p>轻点(Tap) 用来按下或选中一个控件或项目</p>

<p>拖拽(Drag) 用来滚动或切换内容(即,从屏幕一边移动到另一边) 可以拖拽一个对象</p>

<p>滑动(Flick) 用来快速滚动或切换</p>

<p>轻扫(Swipe) 使用一只手指轻扫,可以返回上一个页面,可以显示在分栏视图 中的隐藏视图(仅 iPad),或表格视图里某行的「删除」按钮。在 iPad 上,四指轻扫可以在多个应用之间进行切换。
双击(Double tap) 用来放大内容或图片,并将其置于屏幕中央。 如果内容已被放大,则会将其缩小。
双指开合(Pinch) 双指张开或闭合以放大或缩小内容
长按(Touch and hold) 在可编辑或可选择的文本中会显示放大镜视图,用来 定位光标。</p>

<p>摇晃(Shake) 用来执行撤销或重做操作。</p>

<p>避免为标准手势赋予不同的行为</p>

<p>避免重复创建和标准手势具有相同行为的自定义手势</p>

<p>可以使用复杂手势作为完成任务的快捷方式,但不能是唯一的执行方式</p>

<p>通常,应避免定义新的手势,除非你的 app 是游戏</p>

<p>在 iPad 上,可以考虑使用多指手势</p>

<p>p41:
在内容区域,只在需要时为按钮添加边框或背景。(需要和内容性文字相区分)</p>

<p>p43:
尽可能在用户界面中整合状态和其他相关的反馈信息。(例如微信聊天列表的登录中…)
避免不必要的警告框。</p>

<p>使用选项来让用户输入变得轻松容易。例如,你可以使用选择器或者表格视图代替文本框,因为对大多数人来说,从 一个列表中找到并选中某一项比输入文字要容易。</p>

<p>适当时,从 iOS 获取信息。人们在他们的设备中存储了很多信息。如果你可以很容易地自己找到这些信息,那就不要 要求人们输入它们,例如他们的联系人或日历信息。</p>

<p>通过给予用户有用的信息来平衡信息输入的请求。(让用户觉得自己输入的信息是有用的)</p>

<p>p45:
如果合适,创建与内置动画效果相一致的自定义动画。</p>

<p>一般来说,要确保自定义动画真实可信。人们往往愿意接受外观上的艺术创新,但当他们体验到毫无意义或违背物理 规律的动态效果时仍然会感到怪异和困惑。例如,如果你通过在屏幕顶部往下滑动触发一个视图,你应当可以通过向 上滑动关闭这个视图,这样做有助于用户想起视图是从何而起。如果你通过在屏幕底部往下滑动来关闭同一个视图, 你会打破用户认为屏幕顶部存在可用视图的心智模型。</p>

<p>p49:
API 备注:如果需要给条栏按钮项目着色,请使用 tintColor 属性;若要给条栏本身着色,则使用 barTintColor 属性。</p>

<p>p50:
字体清晰易读</p>

<p>最为首要的是,文字必须清晰易读。如果用户根本看不清你的 app 中的文字,那字体设计得再漂亮也无济于事。在 iOS 7 app 中使用「动态字体」(Dynamic Type),可以实现:
· 自动调整每一种字体大小的字间距和行高
· 为不同语义的文本块指定不同的文本样式,例如正文、脚注或大标题
· 文字会适当响应用户对文字大小的设置更改(包括辅助功能中的文字大小)
注意:如果你在使用自定义字体,仍然可以根据系统设置的文字大小缩放字体。当用户改变设置,你的 app 要做出 适当的响应。
对你来说,使用「动态字体」可能需要一些工作量。如需了解如何使用文本样式并确保你的 app 在用户改变文字大 小设置时得到通知,请参阅《Text Programming Guide for iOS》中「Text Styles」一节。</p>

<p>在响应文字大小的变化时,优先让内容变化。</p>

<p>如果合适,在用户选择不同的文字大小时调整布局。</p>

<p>即便用户选择了最小文字大小,文字也不应小于 22 点。作为对照,正文样式在大字号下使用 34 点字体大小 作为默认文字大小设置。</p>

<p>p54:图像</p>

<p>支持 Retina 显示屏。确保你的 app 中所有的插图和图形元素都有提供 @2x 资源。
以原始宽高比显示照片和图形,且放大比例不超过 100%。你不会希望自己 app 中的差图和图形元素看上去失真或 过大。让用户自己选择是想要放大图像还是缩小图像。
不要在你的设计中使用 Apple 产品的复制图像。这些图像都是有版权的,而且这些产品设计会频繁变更。</p>

<p>p67:定义你的app
App 定义陈述是一份对 app 的主要目的及其目标用户简洁而具体的阐述。</p>

<p>1.列出所有你认为用户会喜欢的功能点
从这一步开始进行头脑风暴。你要尝试记下所有和你主要产品创意相关的任务。不要担心这个列表太长,稍后你会再 做筛选。</p>

<p>2.定义你的目标用户</p>

<p>经过思考这些问题,假设你确定了最符合你目标用户的三个特征:喜欢试验新菜谱、总是很忙、以及在不会太麻烦时 尽量节俭。</p>

<p>3.通过定义目标用户来筛选功能点
在确定了目标用户的特征之后,如果你得到了为数不多的几个特性,那就对了:优秀的 iOS app 都会精准聚焦于它 们所要帮助用户完成的任务。</p>

<p>当你不断在目标用户的情境中去验证特性清单,你就会领悟到你的 app 应该聚焦于三个主要特性:创建清单、获取 使用优惠券和发现食谱。</p>

<p>现在,你可以开始定义你的 app 了,具体地概括 app 是做什么用的以及给谁用。对于这个食物采购 app,一个好的 定义陈述可能是这样的:
「一个购物清单创建工具,为勤俭的美食家而生。」</p>

<p>4.继续向前
在整个开发过程中,始终要用你的app 定义陈述去判断功能点、控件和用词是否妥当。例如:
当你考虑增加一个新功能时,问问自己,这对你 app 的主要目的和目标用户是不是不可或缺?如果不是,把它放在 一边,它可能是构建另一个 app 的基础。例如,你已经确定你的用户喜欢探索烹饪,那么强调打包好的蛋糕和加工 好的熟食可能不会被用户喜欢。
当你考虑 UI 的外观和行为时,问问自己,你的目标用户是喜欢简洁流畅的设计,还是一个更明显的主题风格?以用 户对你 app 的期望为指引,例如使用 app 去完成一项重要任务,快速找到一个答案,探究内容详情,或者为了娱 乐。尽管你的购物清单 app 需要易于理解而且立即可以上手,但你的用户可能会更喜欢一个展示着大量美味食材图 片的界面主题。
当你在考量术语时,努力去迎合你的受众的专业认知。例如,即便你的受众不太可能由专业厨师组成,但你也应该明 白,用户会希望看到配方和技术方面的专业术语。</p>

<p>p79:原型和迭代</p>

<p>在你真正投入开发资源去完成你的设计前,创建一个原型去做用户测试会是很好的做法。即使你只能找到几个同事来 测试这些原型,你仍然会从他们对 app 功能的新鲜视角和体验中获益匪浅。</p>

<p>创建一个可信的原型最为简单的办法就是使用一个基于故事板(Storyboard-based)的 Xcode 模板去创建一个 基本 app,并填充一些合适的占位内容。</p>

<p>p161:</p>

<p>1.不要使用滑块去显示一个音量控件。如果你需要显示音量滑块,用 MPVolumeView 类去使用系统自带的音量滑块。 请注意,在当前激活的音频输出设备不支持音量控制时,音量滑块会被替换为适当的设备名称。</p>

<p>p180:
设计一个app 的第一屏一样的启动画面,如果你认为下面这些准则会导致一个朴素、无趣的启动图像,你说对了。请记住,启动画面并不是一个供你艺术表达 的机会。它的唯一目的是让用户认为你的 app 启动迅速并已准备就绪。</p>
]]></content>
  </entry>
  
</feed>
