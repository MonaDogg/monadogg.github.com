<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | MonaDogg]]></title>
  <link href="http://MonaDogg.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://MonaDogg.github.io/"/>
  <updated>2014-02-25T14:51:03+08:00</updated>
  <id>http://MonaDogg.github.io/</id>
  <author>
    <name><![CDATA[MonaDogg]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[(一)链表笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/02/23/linklistnote/"/>
    <updated>2014-02-23T22:26:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/02/23/linklistnote</id>
    <content type="html"><![CDATA[<p>最近发现自己数据结构和算法十分薄弱,于是准备复习这方面的知识,选用的教材是&lt;算法精解-c语言描述>,在此,把复习中的笔记记录如下.</p>

<p>其中涉及的知识点:</p>

<h2>1.格式化输出函数fprintf()中的stdout、stderr</h2>

<p>printf将格式化写到标准输出，fprintf写至指定的流。</p>

<p>stdin:标准输入
stdout:标准输出
stderr:标准错误</p>

<p>int fprintf(
   FILE <em>stream,                    //为 FILE 结构的指针
   const char </em>format [,
   argument ]&hellip;
);</p>

<h2>2.宏定义的写法</h2>

<p>宏定义默认都大写,不需要类型,没有{}只有()</p>

<pre>
//得到链表中的尾元素
#define list_tail(list) ((list)->tail)

//判断该元素是不是头元素
#define list_is_head(list, element) ((element) == ((list)->head) ? 1 : 0)
</pre>


<h2>3.c语言常用库</h2>

<pre><code>#include &lt;stdlib.h&gt;
//stdlib 头文件即standard library标准库头文件
//本例中用了内存申请和释放:malloc()和free()

#include &lt;string.h&gt;
//C语言里面关于字符数组的函数定义的头文件
//本例中用了memset()重置内存区域
</code></pre>

<h2>4.memset的用法</h2>

<pre><code>//设置缓冲区到制定的位置
void *memset(
   void *dest,      //开始的内存地址
   int c,               //设置值
   size_t count     //设置的长度
);
memset(tempList, 0, sizeof(NewList));
</code></pre>

<p>设置tempList开始的内存地址,长度为NewList类型的长度,值为0</p>

<h2>5.如何申请内存和释放内存</h2>

<p>1)申请内存</p>

<pre><code>if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL)
      return -1;
</code></pre>

<p>2)释放内存</p>

<pre><code>free(willDeleteListElement);
</code></pre>

<h2>6.以下为链表的实现文件</h2>

<p>linkList.h</p>

<pre><code>//
//  linkList.h
//  clist
//
//  Created by lee on 14-2-23.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#ifndef clist_linkList_h
#define clist_linkList_h

//定义链表元素结构
typedef struct LinkListElement_
{
    void *data;
    struct LinkListElement_ *nextElement;
}LinkListElement;

//定义链表结构
typedef struct LinkList_
{
    LinkListElement *headListElement;
    LinkListElement *tailListElement;
    int size;
    //如果data是自定义类型,那么需要初始化的时候设置destroy来释放内存
    void (*destroy)(void *data);
}LinkList;


//初始化链表
void linkListInit(LinkList *linkList,void (* destroy)(void *data));

//删除,返回0为正常,其他为异常
int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data);

//插入
int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data);
//int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,const void *data);

//销毁
void linkListDestroy(LinkList *linkList);

#define LINKLIST_SIZE(linkList) (linkList-&gt;size)
#define LINKLIST_HEAD_ELEMENT(linkList) (linkList-&gt;headListElement)
#define LINKLIST_TAIL_ELEMENT(linkList) (linkList-&gt;tailListElement)
#define LINKLIST_DATA(linklistElement) (linklistElement-&gt;data)
#define LINKLIST_NEXT(linklistElement) (linklistElement-&gt;nextElement)
#define LINKLIST_IS_HEAD_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_HEAD_ELEMENT(linkList) ? 1 : 0 )
#define LINKLIST_IS_TAIL_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_TAIL_ELEMENT(linkList) ? 1 : 0 )

#endif
</code></pre>

<p>linkList.m</p>

<pre><code>//
//  linkList.c
//  clist
//
//  Created by lee on 14-2-25.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "linkList.h"


void linkListInit(LinkList *linkList,void (* destroy)(void *data))
{
    linkList-&gt;headListElement = NULL;
    linkList-&gt;tailListElement = NULL;
    linkList-&gt;size = 0;
    linkList-&gt;destroy = destroy;
    return;
}


//考虑是否从头删除,并且考虑链表新的头尾元素
//非从头删除,需要考虑新的尾元素

int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data)
{


    if (LINKLIST_SIZE(linkList) == 0 || frontListElement == LINKLIST_TAIL_ELEMENT(linkList)) {
        return -1;
    }

    LinkListElement *deleteElement;

#pragma -mark 没有考虑frontListElement = NULL的情况
//    LinkListElement *deleteElement = frontListElement-&gt;nextElement;
//    *data = deleteElement-&gt;data;

    if (frontListElement == NULL) {

        deleteElement = LINKLIST_HEAD_ELEMENT(linkList);
        *data = deleteElement-&gt;data;

        //包含为NULL的情况
        linkList-&gt;headListElement = deleteElement-&gt;nextElement;
        if (LINKLIST_HEAD_ELEMENT(linkList) -&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = LINKLIST_HEAD_ELEMENT(linkList);
        }

    }else{

        deleteElement = frontListElement-&gt;nextElement;
        *data = deleteElement-&gt;data;

        frontListElement-&gt;nextElement = deleteElement-&gt;nextElement;
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = frontListElement;
        }
    }

    free(deleteElement);
    linkList-&gt;size --;
    return 0;
}





//从头插入,判断当前列表是否有元素,进而判断链表的头尾元素
//非从头插入,需要考虑是否插入元素是否为尾元素

int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data)
{
    LinkListElement *insertElement;
    if((insertElement = (LinkListElement *)malloc(sizeof(LinkListElement))) == NULL)
        return -1;
    insertElement-&gt;data = data;

    if (frontListElement == NULL) {
        //如果没有元素,或者没有元素
        if (LINKLIST_SIZE(linkList) == 0) {
            linkList-&gt;tailListElement = insertElement;
        }else{
            insertElement-&gt;nextElement = linkList-&gt;headListElement;
        }
        linkList-&gt;headListElement = insertElement;


    }else{
#pragma -mark 当插入元素是尾元素的情况
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = insertElement;
        }

        insertElement-&gt;nextElement =  frontListElement-&gt;nextElement;
        frontListElement-&gt;nextElement = insertElement;
    }

    linkList-&gt;size ++;

    return 0;
}






//需要遍历释放list中的各个元素的data,并且需要判断destroy是否存在

void linkListDestroy(LinkList *linkList)
{
    void *data = NULL;

    while (LINKLIST_SIZE(linkList) &gt; 0) {

#pragma -mark 不要忘记destroy为NULL的情况
        if(linkListDelete(linkList, NULL, (void **)data) == 0 &amp;&amp; linkList-&gt;destroy != NULL ){
            linkList-&gt;destroy(data);
        }
    }

    memset(linkList,0,sizeof(LinkList));
}
</code></pre>

<p>双向链表:与链表的差距仅仅是多了一个前驱指针,在代码上的差别是,仅仅允许在链表为空的时候,才能从链表的头部插入指针.
dlist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef DLIST_H
#define DLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked list elements.                       *
*                                                                            *
*****************************************************************************/

typedef struct DListElmt_ {

void               *data;
struct DListElmt_  *prev;
struct DListElmt_  *next;

} DListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked lists.                               *
*                                                                            *
*****************************************************************************/

typedef struct DList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

DListElmt          *head;
DListElmt          *tail;

} DList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data));

void dlist_destroy(DList *list);

int dlist_ins_next(DList *list, DListElmt *element, const void *data);

int dlist_ins_prev(DList *list, DListElmt *element, const void *data);

int dlist_remove(DList *list, DListElmt *element, void **data);

#define dlist_size(list) ((list)-&gt;size)

#define dlist_head(list) ((list)-&gt;head)

#define dlist_tail(list) ((list)-&gt;tail)

#define dlist_is_head(element) ((element)-&gt;prev == NULL ? 1 : 0)

#define dlist_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)

#define dlist_data(element) ((element)-&gt;data)

#define dlist_next(element) ((element)-&gt;next)

#define dlist_prev(element) ((element)-&gt;prev)

#endif
</code></pre>

<p>dlist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "dlist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ dlist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;
list-&gt;tail = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_destroy(DList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (dlist_size(list) &gt; 0) {

   if (dlist_remove(list, dlist_tail(list), (void **)&amp;data) == 0 &amp;&amp; list-&gt;
      destroy != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(DList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_ins_next(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/


   //    当链表为空的时候,从头部插入元素

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   new_element-&gt;prev = element;

//判断尾元素
   if (element-&gt;next == NULL)
      list-&gt;tail = new_element;
   else
   //判断下一个元素的上元素
      element-&gt;next-&gt;prev = new_element;

   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_prev ----------------------------  *
*                                                                            *
*****************************************************************************/


int dlist_ins_prev(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/
//  只有链表没有元素的时候,才可以从头部插入


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage to be managed by the abstract data type.                 *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }


else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element; 
   new_element-&gt;prev = element-&gt;prev;

   if (element-&gt;prev == NULL)
      list-&gt;head = new_element;
   else
      element-&gt;prev-&gt;next = new_element;

   element-&gt;prev = new_element;

}


/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the new element.               *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- dlist_remove -----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_remove(DList *list, DListElmt *element, void **data) {

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element or removal from an empty list.                *
*                                                                            *
*****************************************************************************/

if (element == NULL || dlist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;data;

if (element == list-&gt;head) {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from the head of the list.                              *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = element-&gt;next;

   if (list-&gt;head == NULL)
      list-&gt;tail = NULL;
   else
      element-&gt;next-&gt;prev = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from other than the head of the list.                   *
   *                                                                         *
   **************************************************************************/

   element-&gt;prev-&gt;next = element-&gt;next;

   if (element-&gt;next == NULL)
      list-&gt;tail = element-&gt;prev;
   else
      element-&gt;next-&gt;prev = element-&gt;prev;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>

<p>循环链表:与链表的差距是没有尾指针,当链表中只有一个元素的时候,该元素的next指向自己.因为没有尾指针,所以实现起来也简单了不少.
clist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef CLIST_H
#define CLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular list elements.                            *
*                                                                            *
*****************************************************************************/

typedef struct CListElmt_ {

void               *data;
struct CListElmt_  *next;

} CListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular lists.                                    *
*                                                                            *
*****************************************************************************/

typedef struct CList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

//仅仅有头指针,没有尾巴指针
CListElmt          *head;

} CList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data));

void clist_destroy(CList *list);

int clist_ins_next(CList *list, CListElmt *element, const void *data);

int clist_rem_next(CList *list, CListElmt *element, void **data);

#define clist_size(list) ((list)-&gt;size)

#define clist_head(list) ((list)-&gt;head)

#define clist_data(element) ((element)-&gt;data)

#define clist_next(element) ((element)-&gt;next)

#endif
</code></pre>

<p>clist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "clist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ clist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void clist_destroy(CList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (clist_size(list) &gt; 0) {

   if (clist_rem_next(list, list-&gt;head, (void **)&amp;data) == 0 &amp;&amp; list-&gt;destroy
      != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(CList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_ins_next(CList *list, CListElmt *element, const void *data) {

CListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (CListElmt *)malloc(sizeof(CListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the element into the list.                                         *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (clist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = new_element;
   list-&gt;head = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_rem_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_rem_next(CList *list, CListElmt *element, void **data) {

CListElmt          *old_element;

/*****************************************************************************
*                                                                            *
*  Do not allow removal from an empty list.                                  *
*                                                                            *
*****************************************************************************/

if (clist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;next-&gt;data;

if (element-&gt;next == element) {

   /**************************************************************************
   *                                                                         *
   *  Handle removing the last element.                                      *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   list-&gt;head = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removing other than the last element.                           *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   element-&gt;next = element-&gt;next-&gt;next;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(old_element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7人机交互指南笔记]]></title>
    <link href="http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji/"/>
    <updated>2014-02-19T16:41:00+08:00</updated>
    <id>http://MonaDogg.github.io/blog/2014/02/19/ios7ren-ji-jiao-hu-zhi-nan-bi-ji</id>
    <content type="html"><![CDATA[<p>p10:
iOS 7 具体体现了以下主旨:
· 依从(Deference)。用户界面(UI)应当有助于用户理解内容并与之互动,而非对抗。
· 清晰(Clarity)。文字在每种字号下都易于阅读,图标表意准确清晰,装饰也恰到其度,并以对功能的无比关 注驱动设计。
· 纵深(Depth)。视觉上的分层界面和逼真的动作使其更赋活力,提升了用户的愉悦和理解。</p>

<p>p17:
拥抱无边框按钮。在 iOS 7中,所有的条栏按钮都没有边框。
如果合适,还可以通过显示纤细的边框或者浅 色背景来让按钮更加突出。</p>

<p>p26:
避免要求用户提供设置信息,代之以:
·关注 80% 用户的需求。这样,大部分用户不需要进行任何设置,因为你的 app 已经按他们期望的方式设置好了。如果有一些功能只有极少数用户可能需要或者大部分用户只会用一次,请抛弃这样的功能。
·尽可能通过其他方式获取信息。如果你可以使用任何内置程序或设备中用户所提供的信息,那就从系统中获取 这些信息,而不要让用户再输一次。
·如果你确实需要提供设置信息,请让人们在你的 app 中输入。然后,尽快存储这些信息(例如,在你 app 的 设置中)。这样一来,在有可能体验到你 app 的乐趣前人们不会被迫切换到 iOS 的「设置」中了。如果人们 将来需要修改这些信息,可以在任何时间前往 app 的设置页面进行修改。
尽可能将登录延后。最好在用户没有登录时就可以通过导航来浏览你的 app 并使用部分功能。用户在在可以做点有 用的事情前通常已经从那些强制他们登录的 app 中离开了。
一般来说,以设备的默认方向启动。在 iPhone 上,其默认方向是竖屏;在 iPad 上,则是设备当前的方向。如果你 的 app 只支持横屏,你应该始终以横屏方式启动,然后让用户在需要时旋转设备。
注意:对于只支持横屏的 app,最好能同时支持横屏竖屏两种状态,即 Home 键会在左侧或右侧的状态。如果设备 已经处于横屏,除非有很好的理由支持,否则只支持横屏的 app 应当就以此方向启动。另外,对只支持横屏的 app,Home 键应该在其右侧。(如需了解更多关于支持不同设备方向的信息,请参阅「响应设备方向的改变」(第 56页))
显示一个和 app 首屏极其相似的启动画面。iOS 会在你的 app 启动的瞬间显示这个启动画面,这可以让用户感觉你 的 app 非常快,并让你有足够的时间去加载内容。参阅「启动画面」(第 180 页)了解如何创建启动画面。
如果可能,避免在用户首次加载你的 app 时让他们阅读免责声明或确认终端用户许可协议。你可以让 App Store 显 示你的免责声明或者终端用户许可协议(EULA),以便人们可以在下载 app 前读到它们。如果你确实需要在 app 内展示这些东西,请确保以一种和 UI 保持和谐的方式将其整合进去,并在商业需求和用户体验间把握平衡。
App 重启后要恢复其状态,以便用户可以从中断的地方继续使用,而不要让用户去记住如何返回之前所在的位置。如 需了解更多关于高效重建和恢复 app 状态的方式,请参阅「State Preservation and Restoration」。</p>

<p>随时准备停止
iOS 应用永远不会显示一个「关闭」或「退出」选项。人们退出一个 app 的方式就是切换到另一个 app、返回主屏 幕或者让设备进入睡眠模式。
当人们从你的 app 切换离开,iOS 的多任务处理会将其挂到后台,并切换到新 app 的界面中。为了应对这种情况, 你应当:
·尽快并尽可能频繁地在合理范围内存储用户数据。这样做是因为处于后台的 app 随时都有可能被退出或结束。</p>

<p>启动和停止
随时准备停止,当 app 停止时,尽可能最多地保存当前状态的细节。这样的话,当人们切换回来时就不会失去之前所处的情 境。例如,如果你的 app 有显示可滚动的数据,那在停止时要保存当前所处的滚动位置。你可以前往「State Preservation and Restoration」了解更多关于高效重建和恢复 app 状态的方式。
有些 app 可能需要在用户运行其他 app 时一直在后台运行。例如,当用户在另一款 app 中检查待办事项或者玩游 戏时,他们会希望让正在播放音乐的 app 能继续播放。想要了解如何正确优雅地处理多任务,请参阅「多任务处 理」(第 84 页)。
永远不要以程序化的方式自动退出一个 iOS app。用户有可能会将其认为是程序崩溃了。如果由于一些可预知的问 题导致程序无法使用,那你需要告诉用户发生了什么、他们能做点什么。</p>

<p>p29:
给每个交互元素以足够的间距,以便用户对内容和控件进行操作。可点击控件的点击区域不小于 44 x 44 点。</p>

<p>p30:
将重要内容和功能放到更重要的位置,以便用户可以更容易地关注主要任务。一些可行的方法是,将主要元素放置在 屏幕的上半部分,并靠近屏幕左侧(基于从左至右的阅读习惯).</p>

<p>利用视觉上的权重和平衡来向用户显示界面元素之间的相对重要程度。相比尺寸较小的元素,那些大尺寸的元素更吸 引目光,看上去也更重要。</p>

<p>随时准备应对文字大小的变化。当用户在「设置」中更改文字大小时,他们会希望大多数的 app 可以作出合适的响 应。为适应一些文字字号的变化,你可能需要调整布局;如需了解关于在 app 中显示文字的更多信息,请参阅「文 字清晰易读」(第 49 页)。</p>

<p>p34:
永远要让用户知道自己正处于应用中的什么位置,并清楚如何去往他的下一个目标。</p>

<p>用导航栏来让用户在层级数据之间轻松穿梭。</p>

<p>用标签栏来展示平级分类的内容或功能。</p>

<p>用页码控件来指示有多个子项目或多屏内容。(页码控件?)</p>

<p>总的来说,最好是给用户以唯一的路径前往每个页面。</p>

<p>p37
用户对标准手势了如指掌</p>

<p>轻点(Tap) 用来按下或选中一个控件或项目</p>

<p>拖拽(Drag) 用来滚动或切换内容(即,从屏幕一边移动到另一边) 可以拖拽一个对象</p>

<p>滑动(Flick) 用来快速滚动或切换</p>

<p>轻扫(Swipe) 使用一只手指轻扫,可以返回上一个页面,可以显示在分栏视图 中的隐藏视图(仅 iPad),或表格视图里某行的「删除」按钮。在 iPad 上,四指轻扫可以在多个应用之间进行切换。
双击(Double tap) 用来放大内容或图片,并将其置于屏幕中央。 如果内容已被放大,则会将其缩小。
双指开合(Pinch) 双指张开或闭合以放大或缩小内容
长按(Touch and hold) 在可编辑或可选择的文本中会显示放大镜视图,用来 定位光标。</p>

<p>摇晃(Shake) 用来执行撤销或重做操作。</p>

<p>避免为标准手势赋予不同的行为</p>

<p>避免重复创建和标准手势具有相同行为的自定义手势</p>

<p>可以使用复杂手势作为完成任务的快捷方式,但不能是唯一的执行方式</p>

<p>通常,应避免定义新的手势,除非你的 app 是游戏</p>

<p>在 iPad 上,可以考虑使用多指手势</p>

<p>p41:
在内容区域,只在需要时为按钮添加边框或背景。(需要和内容性文字相区分)</p>

<p>p43:
尽可能在用户界面中整合状态和其他相关的反馈信息。(例如微信聊天列表的登录中…)
避免不必要的警告框。</p>

<p>使用选项来让用户输入变得轻松容易。例如,你可以使用选择器或者表格视图代替文本框,因为对大多数人来说,从 一个列表中找到并选中某一项比输入文字要容易。</p>

<p>适当时,从 iOS 获取信息。人们在他们的设备中存储了很多信息。如果你可以很容易地自己找到这些信息,那就不要 要求人们输入它们,例如他们的联系人或日历信息。</p>

<p>通过给予用户有用的信息来平衡信息输入的请求。(让用户觉得自己输入的信息是有用的)</p>

<p>p45:
如果合适,创建与内置动画效果相一致的自定义动画。</p>

<p>一般来说,要确保自定义动画真实可信。人们往往愿意接受外观上的艺术创新,但当他们体验到毫无意义或违背物理 规律的动态效果时仍然会感到怪异和困惑。例如,如果你通过在屏幕顶部往下滑动触发一个视图,你应当可以通过向 上滑动关闭这个视图,这样做有助于用户想起视图是从何而起。如果你通过在屏幕底部往下滑动来关闭同一个视图, 你会打破用户认为屏幕顶部存在可用视图的心智模型。</p>

<p>p49:
API 备注:如果需要给条栏按钮项目着色,请使用 tintColor 属性;若要给条栏本身着色,则使用 barTintColor 属性。</p>

<p>p50:
字体清晰易读</p>

<p>最为首要的是,文字必须清晰易读。如果用户根本看不清你的 app 中的文字,那字体设计得再漂亮也无济于事。在 iOS 7 app 中使用「动态字体」(Dynamic Type),可以实现:
· 自动调整每一种字体大小的字间距和行高
· 为不同语义的文本块指定不同的文本样式,例如正文、脚注或大标题
· 文字会适当响应用户对文字大小的设置更改(包括辅助功能中的文字大小)
注意:如果你在使用自定义字体,仍然可以根据系统设置的文字大小缩放字体。当用户改变设置,你的 app 要做出 适当的响应。
对你来说,使用「动态字体」可能需要一些工作量。如需了解如何使用文本样式并确保你的 app 在用户改变文字大 小设置时得到通知,请参阅《Text Programming Guide for iOS》中「Text Styles」一节。</p>

<p>在响应文字大小的变化时,优先让内容变化。</p>

<p>如果合适,在用户选择不同的文字大小时调整布局。</p>

<p>即便用户选择了最小文字大小,文字也不应小于 22 点。作为对照,正文样式在大字号下使用 34 点字体大小 作为默认文字大小设置。</p>

<p>p54:图像</p>

<p>支持 Retina 显示屏。确保你的 app 中所有的插图和图形元素都有提供 @2x 资源。
以原始宽高比显示照片和图形,且放大比例不超过 100%。你不会希望自己 app 中的差图和图形元素看上去失真或 过大。让用户自己选择是想要放大图像还是缩小图像。
不要在你的设计中使用 Apple 产品的复制图像。这些图像都是有版权的,而且这些产品设计会频繁变更。</p>

<p>p67:定义你的app
App 定义陈述是一份对 app 的主要目的及其目标用户简洁而具体的阐述。</p>

<p>1.列出所有你认为用户会喜欢的功能点
从这一步开始进行头脑风暴。你要尝试记下所有和你主要产品创意相关的任务。不要担心这个列表太长,稍后你会再 做筛选。</p>

<p>2.定义你的目标用户</p>

<p>经过思考这些问题,假设你确定了最符合你目标用户的三个特征:喜欢试验新菜谱、总是很忙、以及在不会太麻烦时 尽量节俭。</p>

<p>3.通过定义目标用户来筛选功能点
在确定了目标用户的特征之后,如果你得到了为数不多的几个特性,那就对了:优秀的 iOS app 都会精准聚焦于它 们所要帮助用户完成的任务。</p>

<p>当你不断在目标用户的情境中去验证特性清单,你就会领悟到你的 app 应该聚焦于三个主要特性:创建清单、获取 使用优惠券和发现食谱。</p>

<p>现在,你可以开始定义你的 app 了,具体地概括 app 是做什么用的以及给谁用。对于这个食物采购 app,一个好的 定义陈述可能是这样的:
「一个购物清单创建工具,为勤俭的美食家而生。」</p>

<p>4.继续向前
在整个开发过程中,始终要用你的app 定义陈述去判断功能点、控件和用词是否妥当。例如:
当你考虑增加一个新功能时,问问自己,这对你 app 的主要目的和目标用户是不是不可或缺?如果不是,把它放在 一边,它可能是构建另一个 app 的基础。例如,你已经确定你的用户喜欢探索烹饪,那么强调打包好的蛋糕和加工 好的熟食可能不会被用户喜欢。
当你考虑 UI 的外观和行为时,问问自己,你的目标用户是喜欢简洁流畅的设计,还是一个更明显的主题风格?以用 户对你 app 的期望为指引,例如使用 app 去完成一项重要任务,快速找到一个答案,探究内容详情,或者为了娱 乐。尽管你的购物清单 app 需要易于理解而且立即可以上手,但你的用户可能会更喜欢一个展示着大量美味食材图 片的界面主题。
当你在考量术语时,努力去迎合你的受众的专业认知。例如,即便你的受众不太可能由专业厨师组成,但你也应该明 白,用户会希望看到配方和技术方面的专业术语。</p>

<p>p79:原型和迭代</p>

<p>在你真正投入开发资源去完成你的设计前,创建一个原型去做用户测试会是很好的做法。即使你只能找到几个同事来 测试这些原型,你仍然会从他们对 app 功能的新鲜视角和体验中获益匪浅。</p>

<p>创建一个可信的原型最为简单的办法就是使用一个基于故事板(Storyboard-based)的 Xcode 模板去创建一个 基本 app,并填充一些合适的占位内容。</p>

<p>p161:</p>

<p>1.不要使用滑块去显示一个音量控件。如果你需要显示音量滑块,用 MPVolumeView 类去使用系统自带的音量滑块。 请注意,在当前激活的音频输出设备不支持音量控制时,音量滑块会被替换为适当的设备名称。</p>

<p>p180:
设计一个app 的第一屏一样的启动画面,如果你认为下面这些准则会导致一个朴素、无趣的启动图像,你说对了。请记住,启动画面并不是一个供你艺术表达 的机会。它的唯一目的是让用户认为你的 app 启动迅速并已准备就绪。</p>
]]></content>
  </entry>
  
</feed>
