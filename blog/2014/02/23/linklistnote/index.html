
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>(一)链表笔记 - MonaDogg</title>
	<meta name="author" content="MonaDogg">

	
	<meta name="description" content="最近发现自己数据结构和算法十分薄弱,于是准备复习这方面的知识,选用的教材是&lt;算法精解-c语言描述>,在此,把复习中的笔记记录如下. 其中涉及的知识点: 1.格式化输出函数fprintf()中的stdout、stderr printf将格式化写到标准输出，fprintf写至指定的流。 &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="MonaDogg" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="/javascripts/jquery-1.7.2.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">MonaDogg</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/os">OS</a></li>
	<li><a href="/blog/categories/myLife">myLife</a></li>
	<li><a href="/about_me">aboutMe</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/os">OS</a></li>
	<li><a href="/blog/categories/myLife">myLife</a></li>
	<li><a href="/about_me">aboutMe</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:MonaDogg.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:MonaDogg.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">(一)链表笔记</h2>
	<div class="entry-content"><p>最近发现自己数据结构和算法十分薄弱,于是准备复习这方面的知识,选用的教材是&lt;算法精解-c语言描述>,在此,把复习中的笔记记录如下.</p>

<p>其中涉及的知识点:</p>

<h2>1.格式化输出函数fprintf()中的stdout、stderr</h2>

<p>printf将格式化写到标准输出，fprintf写至指定的流。</p>

<p>stdin:标准输入
stdout:标准输出
stderr:标准错误</p>

<p>int fprintf(
   FILE <em>stream,                    //为 FILE 结构的指针
   const char </em>format [,
   argument ]&hellip;
);</p>

<h2>2.宏定义的写法</h2>

<p>宏定义默认都大写,不需要类型,没有{}只有()</p>

<pre>
//得到链表中的尾元素
#define list_tail(list) ((list)->tail)

//判断该元素是不是头元素
#define list_is_head(list, element) ((element) == ((list)->head) ? 1 : 0)
</pre>


<h2>3.c语言常用库</h2>

<pre><code>#include &lt;stdlib.h&gt;
//stdlib 头文件即standard library标准库头文件
//本例中用了内存申请和释放:malloc()和free()

#include &lt;string.h&gt;
//C语言里面关于字符数组的函数定义的头文件
//本例中用了memset()重置内存区域
</code></pre>

<h2>4.memset的用法</h2>

<pre><code>//设置缓冲区到制定的位置
void *memset(
   void *dest,      //开始的内存地址
   int c,               //设置值
   size_t count     //设置的长度
);
memset(tempList, 0, sizeof(NewList));
</code></pre>

<p>设置tempList开始的内存地址,长度为NewList类型的长度,值为0</p>

<h2>5.如何申请内存和释放内存</h2>

<p>1)申请内存</p>

<pre><code>if ((new_element = (ListElmt *)malloc(sizeof(ListElmt))) == NULL)
      return -1;
</code></pre>

<p>2)释放内存</p>

<pre><code>free(willDeleteListElement);
</code></pre>

<h2>6.以下为链表的实现文件</h2>

<p>linkList.h</p>

<pre><code>//
//  linkList.h
//  clist
//
//  Created by lee on 14-2-23.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#ifndef clist_linkList_h
#define clist_linkList_h

//定义链表元素结构
typedef struct LinkListElement_
{
    void *data;
    struct LinkListElement_ *nextElement;
}LinkListElement;

//定义链表结构
typedef struct LinkList_
{
    LinkListElement *headListElement;
    LinkListElement *tailListElement;
    int size;
    //如果data是自定义类型,那么需要初始化的时候设置destroy来释放内存
    void (*destroy)(void *data);
}LinkList;


//初始化链表
void linkListInit(LinkList *linkList,void (* destroy)(void *data));

//删除,返回0为正常,其他为异常
int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data);

//插入
int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data);
//int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,const void *data);

//销毁
void linkListDestroy(LinkList *linkList);

#define LINKLIST_SIZE(linkList) (linkList-&gt;size)
#define LINKLIST_HEAD_ELEMENT(linkList) (linkList-&gt;headListElement)
#define LINKLIST_TAIL_ELEMENT(linkList) (linkList-&gt;tailListElement)
#define LINKLIST_DATA(linklistElement) (linklistElement-&gt;data)
#define LINKLIST_NEXT(linklistElement) (linklistElement-&gt;nextElement)
#define LINKLIST_IS_HEAD_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_HEAD_ELEMENT(linkList) ? 1 : 0 )
#define LINKLIST_IS_TAIL_ELEMENT(linkList,linklistElement)(linklistElement == LINKLIST_TAIL_ELEMENT(linkList) ? 1 : 0 )

#endif
</code></pre>

<p>linkList.m</p>

<pre><code>//
//  linkList.c
//  clist
//
//  Created by lee on 14-2-25.
//  Copyright (c) 2014年 lee. All rights reserved.
//

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include "linkList.h"


void linkListInit(LinkList *linkList,void (* destroy)(void *data))
{
    linkList-&gt;headListElement = NULL;
    linkList-&gt;tailListElement = NULL;
    linkList-&gt;size = 0;
    linkList-&gt;destroy = destroy;
    return;
}


//考虑是否从头删除,并且考虑链表新的头尾元素
//非从头删除,需要考虑新的尾元素

int linkListDelete(LinkList *linkList,LinkListElement *frontListElement,void **data)
{


    if (LINKLIST_SIZE(linkList) == 0 || frontListElement == LINKLIST_TAIL_ELEMENT(linkList)) {
        return -1;
    }

    LinkListElement *deleteElement;

#pragma -mark 没有考虑frontListElement = NULL的情况
//    LinkListElement *deleteElement = frontListElement-&gt;nextElement;
//    *data = deleteElement-&gt;data;

    if (frontListElement == NULL) {

        deleteElement = LINKLIST_HEAD_ELEMENT(linkList);
        *data = deleteElement-&gt;data;

        //包含为NULL的情况
        linkList-&gt;headListElement = deleteElement-&gt;nextElement;
        if (LINKLIST_HEAD_ELEMENT(linkList) -&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = LINKLIST_HEAD_ELEMENT(linkList);
        }

    }else{

        deleteElement = frontListElement-&gt;nextElement;
        *data = deleteElement-&gt;data;

        frontListElement-&gt;nextElement = deleteElement-&gt;nextElement;
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = frontListElement;
        }
    }

    free(deleteElement);
    linkList-&gt;size --;
    return 0;
}





//从头插入,判断当前列表是否有元素,进而判断链表的头尾元素
//非从头插入,需要考虑是否插入元素是否为尾元素

int linkListInsert(LinkList *linkList,LinkListElement *frontListElement,void *data)
{
    LinkListElement *insertElement;
    if((insertElement = (LinkListElement *)malloc(sizeof(LinkListElement))) == NULL)
        return -1;
    insertElement-&gt;data = data;

    if (frontListElement == NULL) {
        //如果没有元素,或者没有元素
        if (LINKLIST_SIZE(linkList) == 0) {
            linkList-&gt;tailListElement = insertElement;
        }else{
            insertElement-&gt;nextElement = linkList-&gt;headListElement;
        }
        linkList-&gt;headListElement = insertElement;


    }else{
#pragma -mark 当插入元素是尾元素的情况
        if (frontListElement-&gt;nextElement == NULL) {
            linkList-&gt;tailListElement = insertElement;
        }

        insertElement-&gt;nextElement =  frontListElement-&gt;nextElement;
        frontListElement-&gt;nextElement = insertElement;
    }

    linkList-&gt;size ++;

    return 0;
}






//需要遍历释放list中的各个元素的data,并且需要判断destroy是否存在

void linkListDestroy(LinkList *linkList)
{
    void *data = NULL;

    while (LINKLIST_SIZE(linkList) &gt; 0) {

#pragma -mark 不要忘记destroy为NULL的情况
        if(linkListDelete(linkList, NULL, (void **)data) == 0 &amp;&amp; linkList-&gt;destroy != NULL ){
            linkList-&gt;destroy(data);
        }
    }

    memset(linkList,0,sizeof(LinkList));
}
</code></pre>

<p>双向链表:与链表的差距仅仅是多了一个前驱指针,在代码上的差别是,仅仅允许在链表为空的时候,才能从链表的头部插入指针.
dlist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef DLIST_H
#define DLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked list elements.                       *
*                                                                            *
*****************************************************************************/

typedef struct DListElmt_ {

void               *data;
struct DListElmt_  *prev;
struct DListElmt_  *next;

} DListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for doubly-linked lists.                               *
*                                                                            *
*****************************************************************************/

typedef struct DList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

DListElmt          *head;
DListElmt          *tail;

} DList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data));

void dlist_destroy(DList *list);

int dlist_ins_next(DList *list, DListElmt *element, const void *data);

int dlist_ins_prev(DList *list, DListElmt *element, const void *data);

int dlist_remove(DList *list, DListElmt *element, void **data);

#define dlist_size(list) ((list)-&gt;size)

#define dlist_head(list) ((list)-&gt;head)

#define dlist_tail(list) ((list)-&gt;tail)

#define dlist_is_head(element) ((element)-&gt;prev == NULL ? 1 : 0)

#define dlist_is_tail(element) ((element)-&gt;next == NULL ? 1 : 0)

#define dlist_data(element) ((element)-&gt;data)

#define dlist_next(element) ((element)-&gt;next)

#define dlist_prev(element) ((element)-&gt;prev)

#endif
</code></pre>

<p>dlist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- dlist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "dlist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ dlist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_init(DList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;
list-&gt;tail = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void dlist_destroy(DList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (dlist_size(list) &gt; 0) {

   if (dlist_remove(list, dlist_tail(list), (void **)&amp;data) == 0 &amp;&amp; list-&gt;
      destroy != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(DList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_ins_next(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/


   //    当链表为空的时候,从头部插入元素

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   new_element-&gt;prev = element;

//判断尾元素
   if (element-&gt;next == NULL)
      list-&gt;tail = new_element;
   else
   //判断下一个元素的上元素
      element-&gt;next-&gt;prev = new_element;

   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- dlist_ins_prev ----------------------------  *
*                                                                            *
*****************************************************************************/


int dlist_ins_prev(DList *list, DListElmt *element, const void *data) {

DListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element unless the list is empty.                     *
*                                                                            *
*****************************************************************************/
//  只有链表没有元素的时候,才可以从头部插入


if (element == NULL &amp;&amp; dlist_size(list) != 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Allocate storage to be managed by the abstract data type.                 *
*                                                                            *
*****************************************************************************/

if ((new_element = (DListElmt *)malloc(sizeof(DListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the new element into the list.                                     *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (dlist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = new_element;
   list-&gt;head-&gt;prev = NULL;
   list-&gt;head-&gt;next = NULL;
   list-&gt;tail = new_element;

   }


else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element; 
   new_element-&gt;prev = element-&gt;prev;

   if (element-&gt;prev == NULL)
      list-&gt;head = new_element;
   else
      element-&gt;prev-&gt;next = new_element;

   element-&gt;prev = new_element;

}


/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the new element.               *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ----------------------------- dlist_remove -----------------------------  *
*                                                                            *
*****************************************************************************/

int dlist_remove(DList *list, DListElmt *element, void **data) {

/*****************************************************************************
*                                                                            *
*  Do not allow a NULL element or removal from an empty list.                *
*                                                                            *
*****************************************************************************/

if (element == NULL || dlist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;data;

if (element == list-&gt;head) {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from the head of the list.                              *
   *                                                                         *
   **************************************************************************/

   list-&gt;head = element-&gt;next;

   if (list-&gt;head == NULL)
      list-&gt;tail = NULL;
   else
      element-&gt;next-&gt;prev = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removal from other than the head of the list.                   *
   *                                                                         *
   **************************************************************************/

   element-&gt;prev-&gt;next = element-&gt;next;

   if (element-&gt;next == NULL)
      list-&gt;tail = element-&gt;prev;
   else
      element-&gt;next-&gt;prev = element-&gt;prev;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>

<p>循环链表:与链表的差距是没有尾指针,当链表中只有一个元素的时候,该元素的next指向自己.因为没有尾指针,所以实现起来也简单了不少.
clist.h</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.h --------------------------------  *
*                                                                            *
*****************************************************************************/

#ifndef CLIST_H
#define CLIST_H

#include &lt;stdlib.h&gt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular list elements.                            *
*                                                                            *
*****************************************************************************/

typedef struct CListElmt_ {

void               *data;
struct CListElmt_  *next;

} CListElmt;

/*****************************************************************************
*                                                                            *
*  Define a structure for circular lists.                                    *
*                                                                            *
*****************************************************************************/

typedef struct CList_ {

int                size;

int                (*match)(const void *key1, const void *key2);
void               (*destroy)(void *data);

//仅仅有头指针,没有尾巴指针
CListElmt          *head;

} CList;

/*****************************************************************************
*                                                                            *
*  --------------------------- Public Interface ---------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data));

void clist_destroy(CList *list);

int clist_ins_next(CList *list, CListElmt *element, const void *data);

int clist_rem_next(CList *list, CListElmt *element, void **data);

#define clist_size(list) ((list)-&gt;size)

#define clist_head(list) ((list)-&gt;head)

#define clist_data(element) ((element)-&gt;data)

#define clist_next(element) ((element)-&gt;next)

#endif
</code></pre>

<p>clist.c</p>

<pre><code>/*****************************************************************************
*                                                                            *
*  ------------------------------- clist.c --------------------------------  *
*                                                                            *
*****************************************************************************/

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

#include "clist.h"

/*****************************************************************************
*                                                                            *
*  ------------------------------ clist_init ------------------------------  *
*                                                                            *
*****************************************************************************/

void clist_init(CList *list, void (*destroy)(void *data)) {

/*****************************************************************************
*                                                                            *
*  Initialize the list.                                                      *
*                                                                            *
*****************************************************************************/

list-&gt;size = 0;
list-&gt;destroy = destroy;
list-&gt;head = NULL;

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_destroy -----------------------------  *
*                                                                            *
*****************************************************************************/

void clist_destroy(CList *list) {

void               *data;

/*****************************************************************************
*                                                                            *
*  Remove each element.                                                      *
*                                                                            *
*****************************************************************************/

while (clist_size(list) &gt; 0) {

   if (clist_rem_next(list, list-&gt;head, (void **)&amp;data) == 0 &amp;&amp; list-&gt;destroy
      != NULL) {

      /***********************************************************************
      *                                                                      *
      *  Call a user-defined function to free dynamically allocated data.    *
      *                                                                      *
      ***********************************************************************/

      list-&gt;destroy(data);

   }

}

/*****************************************************************************
*                                                                            *
*  No operations are allowed now, but clear the structure as a precaution.   *
*                                                                            *
*****************************************************************************/

memset(list, 0, sizeof(CList));

return;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_ins_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_ins_next(CList *list, CListElmt *element, const void *data) {

CListElmt          *new_element;

/*****************************************************************************
*                                                                            *
*  Allocate storage for the element.                                         *
*                                                                            *
*****************************************************************************/

if ((new_element = (CListElmt *)malloc(sizeof(CListElmt))) == NULL)
   return -1;

/*****************************************************************************
*                                                                            *
*  Insert the element into the list.                                         *
*                                                                            *
*****************************************************************************/

new_element-&gt;data = (void *)data;

if (clist_size(list) == 0) {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is empty.                               *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = new_element;
   list-&gt;head = new_element;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle insertion when the list is not empty.                           *
   *                                                                         *
   **************************************************************************/

   new_element-&gt;next = element-&gt;next;
   element-&gt;next = new_element;

}

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the inserted element.          *
*                                                                            *
*****************************************************************************/

list-&gt;size++;

return 0;

}

/*****************************************************************************
*                                                                            *
*  ---------------------------- clist_rem_next ----------------------------  *
*                                                                            *
*****************************************************************************/

int clist_rem_next(CList *list, CListElmt *element, void **data) {

CListElmt          *old_element;

/*****************************************************************************
*                                                                            *
*  Do not allow removal from an empty list.                                  *
*                                                                            *
*****************************************************************************/

if (clist_size(list) == 0)
   return -1;

/*****************************************************************************
*                                                                            *
*  Remove the element from the list.                                         *
*                                                                            *
*****************************************************************************/

*data = element-&gt;next-&gt;data;

if (element-&gt;next == element) {

   /**************************************************************************
   *                                                                         *
   *  Handle removing the last element.                                      *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   list-&gt;head = NULL;

   }

else {

   /**************************************************************************
   *                                                                         *
   *  Handle removing other than the last element.                           *
   *                                                                         *
   **************************************************************************/

   old_element = element-&gt;next;
   element-&gt;next = element-&gt;next-&gt;next;

}

/*****************************************************************************
*                                                                            *
*  Free the storage allocated by the abstract data type.                     *
*                                                                            *
*****************************************************************************/

free(old_element);

/*****************************************************************************
*                                                                            *
*  Adjust the size of the list to account for the removed element.           *
*                                                                            *
*****************************************************************************/

list-&gt;size--;

return 0;

}
</code></pre>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-02-23T22:26:00+08:00" pubdate data-updated="true">Feb 23<span>rd</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		
	</div>
	
</div>



     <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_xiaoyou"></a>
	<a href="http://www.jiathis.com/share?uid=1865940" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=1354413288083326" charset="utf-8"></script>
<!-- JiaThis Button END -->

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1865940"></script>
<!-- UY END -->


</div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    MonaDogg

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>