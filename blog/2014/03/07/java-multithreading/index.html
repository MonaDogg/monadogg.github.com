
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>《java并发编程实战》读书笔记 - MonaDogg</title>
	<meta name="author" content="MonaDogg">

	
	<meta name="description" content="第一章.简介 如果想要充分发挥多处理器系统的强大计算能力,最简单的方式就是使用线程. 在不同进程之间可以通过一些粗粒度的通信机制来交换数据,包括:套接字,信号处理器,共享内存,信号量以及文件等. 一种高效的运行方式是通过粗粒度的时间分片使这些用户和程序能共享计算机的资源. &hellip;">
	
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

	<link href="/atom.xml" rel="alternate" title="MonaDogg" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script async="true" src="/javascripts/jquery-1.7.2.min.js"></script>
	
</head>


<body>
	<header id="header" class="inner"><h1><a href="/">MonaDogg</a></h1>
<nav id="main-nav"><ul class="main">
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/os">OS</a></li>
	<li><a href="/blog/categories/myLife">myLife</a></li>
	<li><a href="/about_me">aboutMe</a></li>
</ul>
</nav>
<nav id="mobile-nav">
	<div class="alignleft menu">
		<a class="button">Menu</a>
		<div class="container"><ul class="main">
	<li><a href="/blog/categories/ios">iOS</a></li>
	<li><a href="/blog/categories/os">OS</a></li>
	<li><a href="/blog/categories/myLife">myLife</a></li>
	<li><a href="/about_me">aboutMe</a></li>
</ul>
</div>
	</div>
	<div class="alignright search">
		<a class="button"></a>
		<div class="container">
			<form action="http://google.com/search" method="get">
				<input type="text" name="q" results="0">
				<input type="hidden" name="q" value="site:MonaDogg.github.io">
			</form>
		</div>
	</div>
</nav>
<nav id="sub-nav" class="alignright">
	<div class="social">
		
		
		
		
    
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
    
	</div>
	<form class="search" action="http://google.com/search" method="get">
		<input class="alignright" type="text" name="q" results="0">
		<input type="hidden" name="q" value="site:MonaDogg.github.io">
	</form>
</nav>

</header>
	
		
	
	<div id="content" class="inner"><article class="post">
	<h2 class="title">《java并发编程实战》读书笔记</h2>
	<div class="entry-content"><h1>第一章.简介</h1>

<p>如果想要充分发挥多处理器系统的强大计算能力,最简单的方式就是使用线程.</p>

<p>在不同进程之间可以通过一些粗粒度的通信机制来交换数据,包括:套接字,信号处理器,共享内存,信号量以及文件等.</p>

<p>一种高效的运行方式是通过粗粒度的时间分片使这些用户和程序能共享计算机的资源.</p>

<p>线程会共享进程范围内的资源,例如内存句柄和文件句柄,但每个线程都有各自的程序计数器,栈以及局部变量等.</p>

<p>如果没有明确的协同机制,那么线程将彼此独立执行,由于同一个进程中的所有线程都将共享进程的内存地址空间,因此这些线程都能够访问相同的变量并在同一个堆上分配对象,这就需要
实现一种比在进程间共享数据粒度更细的数据共享机制,如果没有明确的同步机制来协同对共享数据的访问,那么当一个线程正在使用某个变量的时候,另一个线程可以同时访问这个变量
,这将造成不可预测的结果.</p>

<p>这就好比在等待水烧开的同时看报纸,而不是等到水烧开之后再开始看报纸.</p>

<p>线程安全性可能是非常复杂的,没有充足同步的情况下,多个线程中的执行顺序是不可预测的,甚至会产生奇怪的结果.</p>

<p>安全性问题:永远不发生糟糕的事情,不要顺序错误的执行.
活跃性问题:某件正确的事情最终会发生,当某个操作无法执行下去,就会产生活跃性问题,例如死锁.
性能问题:在多线程程序中,当线程调度器临时挂起活跃线程并转而运行另一个线程时,就会频繁的出现上下文切换操作,这种操作会带来极大的开销,当线程共享数据的时候,必须使用同步
机制,这些机制往往造成编译器优化,使的内存缓存区中的数据无效.</p>

<p>swing的一些组件并不是线程安全的,swing程序通过将所有对GUI组件的访问局限在事件线程中以实现线程的安全性,如果某个应用程序希望在事件线程之外控制GUI,那么必须
将控制GUI的代码放在事件线程中运行.</p>

<h1>第二章.线程安全性</h1>

<p>要编写线程安全的代码,其核心在于要对状态访问操作进行管理,特别是对共享的和可变的状态的访问.</p>

<p>从非正式的意义上来说,对象的状态是指存储在状态变量(例如实例或者静态域)中的数据,对象的状态可能包含其他依赖对象的域,例如HashMap.</p>

<p>&ldquo;共享&#8221;意味着变量可以由多个线程同时访问,而&#8221;可变&#8221;则意味着变量的值在其生命周期内可以发生变化.</p>

<p>一个对象是否需要是线程安全的,取决于它是否被多个线程访问,这指的是在程序中访问对象的方式,而不是对象要实现的功能,要使得对象是线程安全的,需要采用同步机制来协同可变状态的
访问.</p>

<p>当多个线程访问某个状态变量并且其中有一个线程执行写入操作的时候,必须采用同步机制协同这些线程对变量的访问.(关键字:synchronized),但同步这个术语还包含volatile类型的
变量,显式锁(explicit lock)以及原子变量.</p>

<p>如果有多个线程访问同一个可变的状态变量的时,没有使用合适的同步,那么程序就会出现错误,有三种方法可以修复这种问题:</p>

<pre><code>1)不在线程之间共享该状态变量
2)将状态变量修改为不可变的变量
3)在访问状态变量的时候使用同步
</code></pre>

<p>在编写并发应用程序的时候,一种正确的编程方法是,首先让代码正确的运行,然后再提高代码的速度.</p>

<p>当多个线程访问某个类的时候,这个类始终都能保持为正确的行为,那么称这个类为线程安全的.</p>

<p>如果在线程安全类中封装了必要的同步机制,那么客户端无需进一步的采取同步措施.</p>

<p>无状态的对象一定是线程安全的,(例如servlet,既不包含任何域,也不包含任何对其它类中遇的引用).</p>

<p>原子性:原子操作是不可分割的，在执行完毕不会被任何其它任务或事件中断, 能够在单条指令中完成的操作都可以认为是&#8221; 原子操作&#8221;.</p>

<p>&ldquo;读取-修改-写入&#8221;操作序列,其结果依赖于之前的状态.</p>

<p>竞态条件(race condition):在并发变编程中,这种由于不恰当的执行时序而出现不正确的结果,称为竞态条件.</p>

<p>最常见的竞态类型是&#8221;先检查后执行&#8221;操作,通过一个可能失效的观测结果来决定下一步的操作.例如:构建单例的时候,容易产生竞态条件.</p>

<p>另外一种竞态条件是&#8221;读取-修改-写入&#8221;这种操作.</p>

<p>要避免竞态条件问题,就必须在某个线程修改该变量的时,通过某种方式阻止其他线程使用这个变量,从而确保其他线程只能在修改操作完成之前或之后读取和修改状态,而不是在修改状态
过程中.</p>

<p>在实际情况中,应尽可能的使用现有的线程安全对象来管理类的状态,与非线程安全对象相比,判断线程安全的对象可能的状态及其状态转换情况要更加容易,从而更容易维护和验证线程
安全性.</p>

<p>要保持状态的一致性,就需要在单个原子操作中更新所有相关的状态变量.</p>

<p>内置锁:同步代码块(synchronized block),线程在进入同步代码块之前会自动获得锁,并且在退出代码块的时候,自动释放锁.从而让这一组语句作为一个不可分割的单元被执行.但是这种方法却过于极端
可能会造成效率低下.</p>

<p>重入:内置锁是可以重入的,某个线程获取一个他已有的锁,这个请求就会成功,重入的一种实现方法是,每个锁关联一个获取计数值和一个所有者线程,当计数值为0的时候,这个锁就会被
认为没有任何线程持有,当线程请求一个未被持有的锁时候,jvm记下锁的持有者,并且将获取的计数值为1,如果同一个线程获取就会递增,当线程退出代码快的时候,就会-1,当计数值
为0的时候,这个锁将被释放.</p>

<p>一种常见的加锁约定是,将所有的可变状态都封装在对象的内部,并通过对象的内置锁对所有访问可变状态的代码路径进行同步,使得该对象上不会发生并发访问.</p>

<p>同步代码快应该尽可能的缩小代码范围</p>

<p>当使用锁的时候,你应该清楚代码块中实现的功能,以及在执行该代码快时候是否需要很长的时间,无论是执行计算密集的操作,还是在执行某个可能阻塞的操作,如果持有锁的时间过长
那么就会带来活跃性或者性能的问题.</p>

<h1>第三章:对象的共享</h1>

<p>重排序:在没有同步的情况下,编译器,处理器以及运行时候都可能对操作执行的顺序,进行一些意想不到的调整,在缺乏足够同步的多线程程序中,要相对内存操作的执行顺序进行判断,几乎
无法得到正确的结论.</p>

<p>只要有数据在多个线程之间共享,就使用正确的同步.</p>

<p>为什么在访问同个共享且可变的变量时要求所有线程在同一个锁上同步,就是为了确保某个线程写入该变量的值,对于其他线程来说都是可见的,否则,如果一个线程在未持有正确锁的
情况下读取这个变量,那么读到的可能是一个失效值.</p>

<p>加锁的意义不仅仅局限于互斥行为,还包含内存的可见性,为了确保所有线程都能看到共享变量的最新值,所有执行读操作或者写操作的线程都必须在同一个锁上同步.</p>

<p>volatile变量,用来确保将变量的更新操作通知到其他线程,读取volatile变量的时候总是会返回最新写入的值,因此volatile变量是一种比sychronized关键字更轻量级的同步机制.
仅当volatile变量能够简化代码实现以及对同步策略的验证时,才应该使用它们,应该确保它们自身的状态可见性,和他们引用的状态可见性,以及标识一些重要的程序生命周期
事件的发生,例如:</p>

<pre><code>    volatile boolean asleep;
    ....
        while(!asleep)
            countSomeSheep();
</code></pre>

<p>加锁机制可以保证可见性和原子性,而volatile仅能够保证可见性.</p>

<p>当且仅当满足以下所有条件时,才应该使用volatile变量:
当变量的写入操作不依赖变量的当前值,或者你确保只有单个线程更新变量的值.
该变量不会与其他状态变量一起纳入不变性条件中.
在访问变量时不需要加锁.</p>

<p>当某个对象封闭在一个线程中的时候,这种用法将自动实现线程安全性,即使被封闭的对象本身不是线程安全的.</p>

<p>在volatile变量上存在一种特殊的线程封闭,只要你能确保只有单个线程对共享的volatile变量执行写入操作,那么就可以安全地在这些共享的volatile变量上执行&#8221;读取-修改-写入&#8221;的操作,在这种情况下,
相当于将修改操作封闭在单个线程中以防止发生竞态条件,并且volatile变量的可见性保证还确保了其他线程可以看到最新的值.</p>

<p>不可变对象一定是线程安全的.</p>

<p>当满足下面的条件时候,对象才是不可变的:</p>

<pre><code>对象创建之后,其状态就不可以修改了.
对象的所有域都是final类型.
对象是正确创建的(建议使用工厂方法构建对象,具体来说只有析构函数返回时,this引用才应该从线程公开,析构函数可以将this指针保存到某个地方,只要其他线程不会再构造函数完成之前使用它.
</code></pre>

<p>如何线程都可以在不需要额外同步的情况下安全的访问不可变对象,即使在发布这些对象时没有使用同步.</p>

<p>可变对象必须通过安全的方式来发布,这通常意味着在发布和使用该对象的线程时都必须使用同步.</p>

<pre><code>要安全地发布一个对象,对象的引用以及对象的状态必须同时最其他线程可见,一个正确的构造的对象可以通过以下方式来安全的发布:

在静态初始化函数中初始化一个对象的引用,
将对象的引用保存在volatile类型,或者是AtomicReferance对象中,
将对象的引用保存到某个正确构造对象的final类型域中,
将对象的引用保存到一个由锁保护的域中.
</code></pre>

<p>对于可变对象,不仅在发布对象的时候需要使用同步,并且在每次对象访问的时候,同样需要使用同步来确保后续操作的可见性
对象的发布需求取决于他的可变性:</p>

<pre><code>不可变对象可以通过任意机制来发布
事实不可变对象必须通过安全的方式来发布
可变对象必须通过安全的方式来发布,并且必须是线程安全的或者由某个锁保护起来.
</code></pre>

<p>在并发程序中使用和共享某个对象的时,可以使用一些实用的策略,包括:</p>

<pre><code>线程封闭:线程封闭的对象只能有一个线程拥有,对象被封闭在该线程中,并且只有这个线程修改.
只读共享:在没有额外同步的情况下,共享的只读对象可以由多个对象并发访问,但任何线程都不能修改它,共享的只读对象包括不可变对象,和事实不可变对象.
线程安全共享:线程安全的对象在其内部实现同步,因此多个线程可以通过对象的公有接口来访问而不需要进一步的同步.
保护对象:被保护的对象只能通过持有特定的锁来访问,保护对象包括封装在其他线程安全对象中的对象,以及已发布的并且由某个特定锁保护的对象.
</code></pre>
</div>


<div class="meta">
	<div class="date">








  


<time datetime="2014-03-07T06:12:00+08:00" pubdate data-updated="true">Mar 7<span>th</span>, 2014</time></div>
	<div class="tags">


	<a class='category' href='/blog/categories/ios/'>iOS</a>


</div>
	
</div>
</article>

	<div class="share">
	<div class="addthis_toolbox addthis_default_style ">
		
		
		
		
	</div>
	
</div>



     <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
	<a class="jiathis_button_qzone"></a>
	<a class="jiathis_button_tsina"></a>
	<a class="jiathis_button_tqq"></a>
	<a class="jiathis_button_weixin"></a>
	<a class="jiathis_button_renren"></a>
	<a class="jiathis_button_xiaoyou"></a>
	<a href="http://www.jiathis.com/share?uid=1865940" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
</div>
<script type="text/javascript">
var jiathis_config = {data_track_clickback:'true'};
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code_mini/jia.js?uid=1354413288083326" charset="utf-8"></script>
<!-- JiaThis Button END -->

<!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1865940"></script>
<!-- UY END -->


</div>
	<footer id="footer" class="inner">Copyright &copy; 2014

    MonaDogg

</footer>
	<script src="/javascripts/slash.js"></script>
<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->






</body>
</html>